# Generated by Haxe 4.3.0
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
from threading import RLock as python_lib_threading_RLock
import threading as python_lib_Threading
import os as python_lib_Os
import builtins as python_lib_Builtins
import json as python_lib_Json
import sys as python_lib_Sys
import functools as python_lib_Functools
from io import StringIO as python_lib_io_StringIO
from subprocess import Popen as python_lib_subprocess_Popen
import random as python_lib_Random
import re as python_lib_Re
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from json import JSONEncoder as python_lib_json_JSONEncoder
from threading import Semaphore as python_lib_threading_Semaphore
import requests as requests_externs_NativeRequests


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg


class ExternMain:
    _hx_class_name = "ExternMain"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        _impl_ScriptMain.main()
ExternMain._hx_class = ExternMain


class IntIterator:
    _hx_class_name = "IntIterator"
    _hx_is_interface = "False"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_min,_hx_max):
        self.min = _hx_min
        self.max = _hx_max

    def hasNext(self):
        return (self.min < self.max)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.min
                _hx_local_0.min = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.min = None
        _hx_o.max = None
IntIterator._hx_class = IntIterator


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["filter", "fold"]

    @staticmethod
    def filter(it,f):
        _g = []
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                _g.append(x1)
        return _g

    @staticmethod
    def fold(it,f,first):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            first = f(x1,first)
        return first
Lambda._hx_class = Lambda


class _Math_Math_Impl_:
    _hx_class_name = "_Math.Math_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["min"]

    @staticmethod
    def min(a,b):
        if python_lib_Math.isnan(a):
            return a
        elif python_lib_Math.isnan(b):
            return b
        else:
            return min(a,b)
_Math_Math_Impl_._hx_class = _Math_Math_Impl_


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "callMethod", "isFunction", "compare", "makeVarArgs"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def makeVarArgs(f):
        def _hx_local_0(*v):
            this1 = v
            return f((list(this1) if ((not Std.isOfType(this1,list))) else this1))
        return _hx_local_0
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        _hx_len = len(x)
        index = 0
        while (index < _hx_len):
            if (not (x[index] in " \n\r\t\x0B\x0C")):
                break
            index = (index + 1)
        isNegative = None
        if (index < _hx_len):
            sign = x[index]
            if ((sign == "-") or ((sign == "+"))):
                index = (index + 1)
            isNegative = (sign == "-")
        else:
            isNegative = False
        isHexadecimal = None
        if ((index + 1) < _hx_len):
            cur = x[index]
            next = x[(index + 1)]
            isHexadecimal = ((cur == "0") and (((next == "x") or ((next == "X")))))
        else:
            isHexadecimal = False
        if isHexadecimal:
            index = (index + 2)
        cur = index
        if isHexadecimal:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789abcdefABCDEF")):
                    break
                cur = (cur + 1)
        else:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789")):
                    break
                cur = (cur + 1)
        firstInvalidIndex = cur
        if (index == firstInvalidIndex):
            return None
        result = int(HxString.substring(x,index,firstInvalidIndex),(16 if isHexadecimal else 10))
        if isNegative:
            return -result
        else:
            return result

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim", "lpad", "rpad", "replace", "hex"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def rpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        s1 = Std.string(s)
        buf.b.write(s1)
        while (buf.get_length() < l):
            s = Std.string(c)
            buf.b.write(s)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exists", "isDirectory", "createDirectory", "deleteFile", "deleteDirectory", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)

    @staticmethod
    def deleteDirectory(path):
        python_lib_Os.rmdir(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exit", "args", "getEnv", "getCwd", "systemName"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return python_lib_Os.environ.get(s,None)

    @staticmethod
    def getCwd():
        return haxe_io_Path.addTrailingSlash(python_lib_Os.getcwd())

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "getSuperClass", "createEmptyInstance", "typeof"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class _impl_ScriptMain:
    _hx_class_name = "_impl.ScriptMain"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        __args__ = Sys.args()
        kiss_Prelude.printStr = kiss_Prelude._externPrintStr
        tmp = tink_json_Writer0()
        params = tink_json_Parser0().parse((None if ((len(__args__) == 0)) else __args__.pop(0)))
        mediaWikiUrl = tink_json_Parser1().parse((None if ((len(__args__) == 0)) else __args__.pop(0)))
        maxLag = tink_json_Parser1().parse((None if ((len(__args__) == 0)) else __args__.pop(0)))
        headers = tink_json_Parser2().parse((None if ((len(__args__) == 0)) else __args__.pop(0)))
        kiss_Prelude.print(kiss_Prelude.add("extern query call ",("null" if ((params is None)) else params.toString()),""))
        _g = haxe_ds_StringMap()
        _g.h["action"] = "query"
        _g.h["maxlag"] = maxLag
        _g.h["format"] = "json"
        innerParams = _g
        _hx_map = params
        _g_map = _hx_map
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = _g_map.get(key)
            _g_key = key
            param = _g_key
            paramValues = _g_value
            v = "|".join([python_Boot.toString1(x1,'') for x1 in paramValues])
            innerParams.h[param] = v
        response = requests_externs_Requests.get(mediaWikiUrl,innerParams,_hx_AnonObject({'headers': headers, 'timeout': 2}))
        _mXZXxRfbybKynRJFFRe6gR = response.ok
        if (not kiss_Prelude.truthy(_mXZXxRfbybKynRJFFRe6gR)):
            raise haxe_Exception.thrown(kiss_Prelude.runtimeInsertAssertionMessage("MediaWiki query failed","ScriptMain.kiss:1:734: Assertion failed: \nFrom:[(assert response.ok \"MediaWiki query failed\")]",4))
        kiss_Prelude.print(kiss_Prelude.add("call finished: ",Std.string(response.text),""))
        kiss_Prelude._printStr(tmp.write(response.text))
        Sys.exit(0)
_impl_ScriptMain._hx_class = _impl_ScriptMain

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "keys", "toString"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(Std.string(i1)))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("]")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class sys_thread_Mutex:
    _hx_class_name = "sys.thread.Mutex"
    _hx_is_interface = "False"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]

    def __init__(self):
        self.lock = python_lib_threading_RLock()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lock = None
sys_thread_Mutex._hx_class = sys_thread_Mutex


class sys_thread_EventLoop:
    _hx_class_name = "sys.thread.EventLoop"
    _hx_is_interface = "False"
    __slots__ = ("mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread")
    _hx_fields = ["mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread"]
    _hx_methods = ["repeat", "cancel", "loop"]
    _hx_statics = ["CREATED"]

    def __init__(self):
        self.regularEvents = None
        self.promisedEventsCount = 0
        self.waitLock = sys_thread_Lock()
        self.oneTimeEventsIdx = 0
        self.oneTimeEvents = list()
        self.mutex = sys_thread_Mutex()
        self.isMainThread = (not sys_thread_EventLoop.CREATED)
        sys_thread_EventLoop.CREATED = True

    def repeat(self,event,intervalMs):
        self.mutex.lock.acquire(True)
        interval = (0.001 * intervalMs)
        event1 = sys_thread__EventLoop_RegularEvent(event,(python_lib_Time.time() + interval),interval)
        _g = self.regularEvents
        if (_g is None):
            self.regularEvents = event1
        else:
            current = _g
            previous = None
            while True:
                if (current is None):
                    previous.next = event1
                    event1.previous = previous
                    break
                elif (event1.nextRunTime < current.nextRunTime):
                    event1.next = current
                    current.previous = event1
                    if (previous is None):
                        self.regularEvents = event1
                    else:
                        event1.previous = previous
                        previous.next = event1
                        current.previous = event1
                    break
                else:
                    previous = current
                    current = current.next
        self.waitLock.semaphore.release()
        self.mutex.lock.release()
        return event1

    def cancel(self,eventHandler):
        self.mutex.lock.acquire(True)
        event = eventHandler
        event.cancelled = True
        if (self.regularEvents == event):
            self.regularEvents = event.next
        _g = event.next
        if (_g is not None):
            e = _g
            e.previous = event.previous
        _g = event.previous
        if (_g is not None):
            e = _g
            e.next = event.next
        def _hx_local_0():
            event.previous = None
            return event.previous
        event.next = _hx_local_0()
        self.mutex.lock.release()

    def loop(self):
        recycleRegular = []
        recycleOneTimers = []
        while True:
            now = python_lib_Time.time()
            regularsToRun = recycleRegular
            eventsToRunIdx = 0
            nextEventAt = -1
            self.mutex.lock.acquire(True)
            while self.waitLock.semaphore.acquire(True,0.0):
                pass
            current = self.regularEvents
            while (current is not None):
                if (current.nextRunTime <= now):
                    tmp = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(regularsToRun, tmp, current)
                    current.nextRunTime = (current.nextRunTime + current.interval)
                    nextEventAt = -2
                elif ((nextEventAt == -1) or ((current.nextRunTime < nextEventAt))):
                    nextEventAt = current.nextRunTime
                current = current.next
            self.mutex.lock.release()
            _g = 0
            _g1 = eventsToRunIdx
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not (regularsToRun[i] if i >= 0 and i < len(regularsToRun) else None).cancelled):
                    (regularsToRun[i] if i >= 0 and i < len(regularsToRun) else None).run()
                python_internal_ArrayImpl._set(regularsToRun, i, None)
            eventsToRunIdx = 0
            oneTimersToRun = recycleOneTimers
            self.mutex.lock.acquire(True)
            _g_current = 0
            _g_array = self.oneTimeEvents
            while (_g_current < len(_g_array)):
                _g_value = (_g_array[_g_current] if _g_current >= 0 and _g_current < len(_g_array) else None)
                _g_key = _g_current
                _g_current = (_g_current + 1)
                i1 = _g_key
                event = _g_value
                if (event is None):
                    break
                else:
                    tmp1 = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(oneTimersToRun, tmp1, event)
                    python_internal_ArrayImpl._set(self.oneTimeEvents, i1, None)
            self.oneTimeEventsIdx = 0
            hasPromisedEvents = (self.promisedEventsCount > 0)
            self.mutex.lock.release()
            _g2 = 0
            _g3 = eventsToRunIdx
            while (_g2 < _g3):
                i2 = _g2
                _g2 = (_g2 + 1)
                (oneTimersToRun[i2] if i2 >= 0 and i2 < len(oneTimersToRun) else None)()
                python_internal_ArrayImpl._set(oneTimersToRun, i2, None)
            if self.isMainThread:
                next = haxe_MainLoop.tick()
                if haxe_MainLoop.hasEvents():
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    if (nextEventAt > next):
                        nextEventAt = next
            if (eventsToRunIdx > 0):
                nextEventAt = -2
            r_nextEventAt = nextEventAt
            r_anyTime = hasPromisedEvents
            _g4 = r_anyTime
            _g5 = r_nextEventAt
            _g6 = _g5
            if (_g6 == -2):
                pass
            elif (_g6 == -1):
                if _g4:
                    self.waitLock.semaphore.acquire(True,None)
                else:
                    break
            else:
                time = _g5
                timeout = (time - python_lib_Time.time())
                _this = self.waitLock
                timeout1 = (0 if (python_lib_Math.isnan(0)) else (timeout if (python_lib_Math.isnan(timeout)) else max(0,timeout)))
                _this.semaphore.acquire(True,timeout1)
    CREATED = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mutex = None
        _hx_o.oneTimeEvents = None
        _hx_o.oneTimeEventsIdx = None
        _hx_o.waitLock = None
        _hx_o.promisedEventsCount = None
        _hx_o.regularEvents = None
        _hx_o.isMainThread = None
sys_thread_EventLoop._hx_class = sys_thread_EventLoop


class sys_thread__Thread_HxThread:
    _hx_class_name = "sys.thread._Thread.HxThread"
    _hx_is_interface = "False"
    __slots__ = ("events", "nativeThread")
    _hx_fields = ["events", "nativeThread"]
    _hx_statics = ["threads", "threadsMutex", "mainThread", "current"]

    def __init__(self,t):
        self.events = None
        self.nativeThread = t
    threads = None
    threadsMutex = None
    mainThread = None

    @staticmethod
    def current():
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        ct = python_lib_Threading.current_thread()
        if (ct == python_lib_Threading.main_thread()):
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
            return sys_thread__Thread_HxThread.mainThread
        if (not (ct in sys_thread__Thread_HxThread.threads.h)):
            sys_thread__Thread_HxThread.threads.set(ct,sys_thread__Thread_HxThread(ct))
        t = sys_thread__Thread_HxThread.threads.h.get(ct,None)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.events = None
        _hx_o.nativeThread = None
sys_thread__Thread_HxThread._hx_class = sys_thread__Thread_HxThread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run():
        pass
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    _hx_is_interface = "False"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
haxe_Exception._hx_class = haxe_Exception


class haxe__Int32_Int32_Impl_:
    _hx_class_name = "haxe._Int32.Int32_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["mul", "ucompare"]

    @staticmethod
    def mul(a,b):
        return ((((a * ((b & 65535))) + ((((((a * (HxOverrides.rshift(b, 16))) << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def ucompare(a,b):
        if (a < 0):
            if (b < 0):
                return (((((~b + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - (((~a + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            else:
                return 1
        if (b < 0):
            return -1
        else:
            return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
haxe__Int32_Int32_Impl_._hx_class = haxe__Int32_Int32_Impl_


class haxe__Int64_Int64_Impl_:
    _hx_class_name = "haxe._Int64.Int64_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["divMod"]

    @staticmethod
    def divMod(dividend,divisor):
        if (divisor.high == 0):
            _g = divisor.low
            if (_g == 0):
                raise haxe_Exception.thrown("divide by zero")
            elif (_g == 1):
                return _hx_AnonObject({'quotient': haxe__Int64____Int64(dividend.high,dividend.low), 'modulus': haxe__Int64____Int64(0,0)})
            else:
                pass
        divSign = ((dividend.high < 0) != ((divisor.high < 0)))
        modulus = None
        if (dividend.high < 0):
            high = ((~dividend.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~dividend.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            modulus = haxe__Int64____Int64(high,low)
        else:
            modulus = haxe__Int64____Int64(dividend.high,dividend.low)
        if (divisor.high < 0):
            high = ((~divisor.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~divisor.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            divisor = haxe__Int64____Int64(high,low)
        quotient = haxe__Int64____Int64(0,0)
        mask = haxe__Int64____Int64(0,1)
        while (not ((divisor.high < 0))):
            v = haxe__Int32_Int32_Impl_.ucompare(divisor.high,modulus.high)
            cmp = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(divisor.low,modulus.low))
            b = 1
            b = (b & 63)
            divisor = (haxe__Int64____Int64(divisor.high,divisor.low) if ((b == 0)) else (haxe__Int64____Int64(((((((((divisor.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((divisor.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((divisor.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)))
            b1 = 1
            b1 = (b1 & 63)
            mask = (haxe__Int64____Int64(mask.high,mask.low) if ((b1 == 0)) else (haxe__Int64____Int64(((((((((mask.high << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, ((32 - b1))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((mask.low << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b1 < 32)) else haxe__Int64____Int64(((((mask.low << ((b1 - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)))
            if (cmp >= 0):
                break
        while True:
            b_high = 0
            b_low = 0
            if (not (((mask.high != b_high) or ((mask.low != b_low))))):
                break
            v = haxe__Int32_Int32_Impl_.ucompare(modulus.high,divisor.high)
            if (((v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low))) >= 0):
                quotient = haxe__Int64____Int64(((((quotient.high | mask.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((quotient.low | mask.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                high = (((modulus.high - divisor.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((modulus.low - divisor.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low) < 0):
                    ret = high
                    high = (high - 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                modulus = haxe__Int64____Int64(high,low)
            b = 1
            b = (b & 63)
            mask = (haxe__Int64____Int64(mask.high,mask.low) if ((b == 0)) else (haxe__Int64____Int64(HxOverrides.rshift(mask.high, b),((((((((mask.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(0,HxOverrides.rshift(mask.high, ((b - 32))))))
            b1 = 1
            b1 = (b1 & 63)
            divisor = (haxe__Int64____Int64(divisor.high,divisor.low) if ((b1 == 0)) else (haxe__Int64____Int64(HxOverrides.rshift(divisor.high, b1),((((((((divisor.high << ((32 - b1)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, b1))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b1 < 32)) else haxe__Int64____Int64(0,HxOverrides.rshift(divisor.high, ((b1 - 32))))))
        if divSign:
            high = ((~quotient.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~quotient.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            quotient = haxe__Int64____Int64(high,low)
        if (dividend.high < 0):
            high = ((~modulus.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~modulus.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            modulus = haxe__Int64____Int64(high,low)
        return _hx_AnonObject({'quotient': quotient, 'modulus': modulus})
haxe__Int64_Int64_Impl_._hx_class = haxe__Int64_Int64_Impl_


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    _hx_is_interface = "False"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
haxe__Int64____Int64._hx_class = haxe__Int64____Int64


class haxe_Int64Helper:
    _hx_class_name = "haxe.Int64Helper"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromFloat"]

    @staticmethod
    def fromFloat(f):
        if (python_lib_Math.isnan(f) or (not ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))))):
            raise haxe_Exception.thrown("Number is NaN or Infinite")
        noFractions = (f - (HxOverrides.modf(f, 1)))
        if (noFractions > 9007199254740991):
            raise haxe_Exception.thrown("Conversion overflow")
        if (noFractions < -9007199254740991):
            raise haxe_Exception.thrown("Conversion underflow")
        result = haxe__Int64____Int64(0,0)
        neg = (noFractions < 0)
        rest = (-noFractions if neg else noFractions)
        i = 0
        while (rest >= 1):
            curr = HxOverrides.modf(rest, 2)
            rest = (rest / 2)
            if (curr >= 1):
                a_high = 0
                a_low = 1
                b = i
                b = (b & 63)
                b1 = (haxe__Int64____Int64(a_high,a_low) if ((b == 0)) else (haxe__Int64____Int64(((((((((a_high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a_low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a_low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((a_low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)))
                high = (((result.high + b1.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((result.low + b1.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(low,result.low) < 0):
                    ret = high
                    high = (high + 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                result = haxe__Int64____Int64(high,low)
            i = (i + 1)
        if neg:
            high = ((~result.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~result.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            result = haxe__Int64____Int64(high,low)
        return result
haxe_Int64Helper._hx_class = haxe_Int64Helper


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "sortEvents", "tick"]
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["thread", "eventHandler"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.eventHandler = None
        self.thread = None
        _gthis = self
        self.thread = sys_thread__Thread_HxThread.current()
        def _hx_local_0():
            _gthis.run()
        self.eventHandler = sys_thread__Thread_Thread_Impl_.get_events(self.thread).repeat(_hx_local_0,time_ms)

    def stop(self):
        sys_thread__Thread_Thread_Impl_.get_events(self.thread).cancel(self.eventHandler)

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.thread = None
        _hx_o.eventHandler = None
haxe_Timer._hx_class = haxe_Timer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
haxe_ValueException._hx_class = haxe_ValueException


class haxe_crypto_Md5:
    _hx_class_name = "haxe.crypto.Md5"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["bitOR", "bitXOR", "bitAND", "addme", "rol", "cmn", "ff", "gg", "hh", "ii", "doEncode"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def bitOR(self,a,b):
        lsb = ((a & 1) | ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) | (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitXOR(self,a,b):
        lsb = ((a & 1) ^ ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) ^ (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitAND(self,a,b):
        lsb = ((a & 1) & ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) & (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def addme(self,x,y):
        lsw = (((x & 65535)) + ((y & 65535)))
        msw = ((((x >> 16)) + ((y >> 16))) + ((lsw >> 16)))
        return ((msw << 16) | ((lsw & 65535)))

    def rol(self,num,cnt):
        return ((num << cnt) | (HxOverrides.rshift(num, ((32 - cnt)))))

    def cmn(self,q,a,b,x,s,t):
        return self.addme(self.rol(self.addme(self.addme(a,q),self.addme(x,t)),s),b)

    def ff(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,c),self.bitAND(~b,d)),a,b,x,s,t)

    def gg(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,d),self.bitAND(c,~d)),a,b,x,s,t)

    def hh(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(self.bitXOR(b,c),d),a,b,x,s,t)

    def ii(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(c,self.bitOR(b,~d)),a,b,x,s,t)

    def doEncode(self,x):
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        step = None
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            step = 0
            a = self.ff(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),7,-680876936)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 1)),12,-389564586)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),17,606105819)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 3)),22,-1044525330)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),7,-176418897)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 5)),12,1200080426)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),17,-1473231341)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 7)),22,-45705983)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),7,1770035416)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 9)),12,-1958414417)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),17,-42063)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 11)),22,-1990404162)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),7,1804603682)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 13)),12,-40341101)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),17,-1502002290)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 15)),22,1236535329)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),5,-165796510)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 6)),9,-1069501632)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),14,643717713)
            b = self.gg(b,c,d,a,(x[i] if i >= 0 and i < len(x) else None),20,-373897302)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),5,-701558691)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 10)),9,38016083)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),14,-660478335)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 4)),20,-405537848)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),5,568446438)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 14)),9,-1019803690)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),14,-187363961)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 8)),20,1163531501)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),5,-1444681467)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 2)),9,-51403784)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),14,1735328473)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 12)),20,-1926607734)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),4,-378558)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 8)),11,-2022574463)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),16,1839030562)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 14)),23,-35309556)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),4,-1530992060)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 4)),11,1272893353)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),16,-155497632)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 10)),23,-1094730640)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),4,681279174)
            d = self.hh(d,a,b,c,(x[i] if i >= 0 and i < len(x) else None),11,-358537222)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),16,-722521979)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 6)),23,76029189)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),4,-640364487)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 12)),11,-421815835)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),16,530742520)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 2)),23,-995338651)
            a = self.ii(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),6,-198630844)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 7)),10,1126891415)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),15,-1416354905)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 5)),21,-57434055)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),6,1700485571)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 3)),10,-1894986606)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),15,-1051523)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 1)),21,-2054922799)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),6,1873313359)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 15)),10,-30611744)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),15,-1560198380)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 13)),21,1309151649)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),6,-145523070)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 11)),10,-1120210379)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),15,718787259)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 9)),21,-343485551)
            a = self.addme(a,olda)
            b = self.addme(b,oldb)
            c = self.addme(c,oldc)
            d = self.addme(d,oldd)
            i = (i + 16)
        return [a, b, c, d]

    @staticmethod
    def make(b):
        h = haxe_crypto_Md5().doEncode(haxe_crypto_Md5.bytes2blks(b))
        out = haxe_io_Bytes.alloc(16)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        blksSize = (nblk * 16)
        _g = 0
        _g1 = blksSize
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        i = 0
        while (i < b.length):
            _hx_local_0 = blks
            _hx_local_1 = (i >> 2)
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((b.b[i] << (((((((b.length << 3)) + i) & 3)) << 3))))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            i = (i + 1)
        _hx_local_4 = blks
        _hx_local_5 = (i >> 2)
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 | ((128 << ((HxOverrides.mod((((b.length * 8) + i)), 4) * 8))))))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        l = (b.length * 8)
        k = ((nblk * 16) - 2)
        python_internal_ArrayImpl._set(blks, k, (l & 255))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 8) & 255)) << 8))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 16) & 255)) << 16))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 24) & 255)) << 24))))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Md5._hx_class = haxe_crypto_Md5


class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g = 0
        _g1 = b.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (i >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i] << ((24 - ((((i & 3)) << 3))))))))
        i = b.length
        p = (i >> 2)
        python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((128 << ((24 - ((((i & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Sha1._hx_class = haxe_crypto_Sha1

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"
    _hx_constructs = ["Left", "Right"]

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, (v,))

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, (v,))
haxe_ds_Either._hx_class = haxe_ds_Either

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, (v,))
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, ())
haxe_ds_Option._hx_class = haxe_ds_Option


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("]")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class haxe_format_JsonParser:
    _hx_class_name = "haxe.format.JsonParser"
    _hx_is_interface = "False"
    __slots__ = ("str", "pos")
    _hx_fields = ["str", "pos"]
    _hx_methods = ["doParse", "parseRec", "parseString", "invalidChar", "invalidNumber"]

    def __init__(self,_hx_str):
        self.str = _hx_str
        self.pos = 0

    def doParse(self):
        result = self.parseRec()
        c = None
        while True:
            s = self.str
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (not ((c != -1))):
                break
            c1 = c
            if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                pass
            else:
                self.invalidChar()
        return result

    def parseRec(self):
        while True:
            s = self.str
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            c1 = c
            if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                pass
            elif (c1 == 34):
                return self.parseString()
            elif (((((((((((c1 == 57) or ((c1 == 56))) or ((c1 == 55))) or ((c1 == 54))) or ((c1 == 53))) or ((c1 == 52))) or ((c1 == 51))) or ((c1 == 50))) or ((c1 == 49))) or ((c1 == 48))) or ((c1 == 45))):
                c2 = c
                start = (self.pos - 1)
                minus = (c2 == 45)
                digit = (not minus)
                zero = (c2 == 48)
                point = False
                e = False
                pm = False
                end = False
                while True:
                    s1 = self.str
                    index1 = self.pos
                    self.pos = (self.pos + 1)
                    c2 = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                    c3 = c2
                    if ((c3 == 45) or ((c3 == 43))):
                        if ((not e) or pm):
                            self.invalidNumber(start)
                        digit = False
                        pm = True
                    elif (c3 == 46):
                        if ((minus or point) or e):
                            self.invalidNumber(start)
                        digit = False
                        point = True
                    elif (c3 == 48):
                        if (zero and (not point)):
                            self.invalidNumber(start)
                        if minus:
                            minus = False
                            zero = True
                        digit = True
                    elif (((((((((c3 == 57) or ((c3 == 56))) or ((c3 == 55))) or ((c3 == 54))) or ((c3 == 53))) or ((c3 == 52))) or ((c3 == 51))) or ((c3 == 50))) or ((c3 == 49))):
                        if (zero and (not point)):
                            self.invalidNumber(start)
                        if minus:
                            minus = False
                        digit = True
                        zero = False
                    elif ((c3 == 101) or ((c3 == 69))):
                        if ((minus or zero) or e):
                            self.invalidNumber(start)
                        digit = False
                        e = True
                    else:
                        if (not digit):
                            self.invalidNumber(start)
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.pos
                        _hx_local_0.pos = (_hx_local_1 - 1)
                        _hx_local_1
                        end = True
                    if (not ((not end))):
                        break
                f = Std.parseFloat(HxString.substr(self.str,start,(self.pos - start)))
                if point:
                    return f
                else:
                    i = None
                    try:
                        i = int(f)
                    except BaseException as _g:
                        None
                        i = None
                    i1 = i
                    if (i1 == f):
                        return i1
                    else:
                        return f
            elif (c1 == 91):
                arr = []
                comma = None
                while True:
                    s2 = self.str
                    index2 = self.pos
                    self.pos = (self.pos + 1)
                    c4 = (-1 if ((index2 >= len(s2))) else ord(s2[index2]))
                    c5 = c4
                    if ((((c5 == 32) or ((c5 == 13))) or ((c5 == 10))) or ((c5 == 9))):
                        pass
                    elif (c5 == 44):
                        if comma:
                            comma = False
                        else:
                            self.invalidChar()
                    elif (c5 == 93):
                        if (comma == False):
                            self.invalidChar()
                        return arr
                    else:
                        if comma:
                            self.invalidChar()
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.pos
                        _hx_local_2.pos = (_hx_local_3 - 1)
                        _hx_local_3
                        x = self.parseRec()
                        arr.append(x)
                        comma = True
            elif (c1 == 102):
                save = self.pos
                tmp = None
                tmp1 = None
                tmp2 = None
                s3 = self.str
                index3 = self.pos
                self.pos = (self.pos + 1)
                if (((-1 if ((index3 >= len(s3))) else ord(s3[index3]))) == 97):
                    s4 = self.str
                    index4 = self.pos
                    self.pos = (self.pos + 1)
                    tmp2 = (((-1 if ((index4 >= len(s4))) else ord(s4[index4]))) != 108)
                else:
                    tmp2 = True
                if (not tmp2):
                    s5 = self.str
                    index5 = self.pos
                    self.pos = (self.pos + 1)
                    tmp1 = (((-1 if ((index5 >= len(s5))) else ord(s5[index5]))) != 115)
                else:
                    tmp1 = True
                if (not tmp1):
                    s6 = self.str
                    index6 = self.pos
                    self.pos = (self.pos + 1)
                    tmp = (((-1 if ((index6 >= len(s6))) else ord(s6[index6]))) != 101)
                else:
                    tmp = True
                if tmp:
                    self.pos = save
                    self.invalidChar()
                return False
            elif (c1 == 110):
                save1 = self.pos
                tmp3 = None
                tmp4 = None
                s7 = self.str
                index7 = self.pos
                self.pos = (self.pos + 1)
                if (((-1 if ((index7 >= len(s7))) else ord(s7[index7]))) == 117):
                    s8 = self.str
                    index8 = self.pos
                    self.pos = (self.pos + 1)
                    tmp4 = (((-1 if ((index8 >= len(s8))) else ord(s8[index8]))) != 108)
                else:
                    tmp4 = True
                if (not tmp4):
                    s9 = self.str
                    index9 = self.pos
                    self.pos = (self.pos + 1)
                    tmp3 = (((-1 if ((index9 >= len(s9))) else ord(s9[index9]))) != 108)
                else:
                    tmp3 = True
                if tmp3:
                    self.pos = save1
                    self.invalidChar()
                return None
            elif (c1 == 116):
                save2 = self.pos
                tmp5 = None
                tmp6 = None
                s10 = self.str
                index10 = self.pos
                self.pos = (self.pos + 1)
                if (((-1 if ((index10 >= len(s10))) else ord(s10[index10]))) == 114):
                    s11 = self.str
                    index11 = self.pos
                    self.pos = (self.pos + 1)
                    tmp6 = (((-1 if ((index11 >= len(s11))) else ord(s11[index11]))) != 117)
                else:
                    tmp6 = True
                if (not tmp6):
                    s12 = self.str
                    index12 = self.pos
                    self.pos = (self.pos + 1)
                    tmp5 = (((-1 if ((index12 >= len(s12))) else ord(s12[index12]))) != 101)
                else:
                    tmp5 = True
                if tmp5:
                    self.pos = save2
                    self.invalidChar()
                return True
            elif (c1 == 123):
                obj = _hx_AnonObject({})
                field = None
                comma1 = None
                while True:
                    s13 = self.str
                    index13 = self.pos
                    self.pos = (self.pos + 1)
                    c6 = (-1 if ((index13 >= len(s13))) else ord(s13[index13]))
                    c7 = c6
                    if ((((c7 == 32) or ((c7 == 13))) or ((c7 == 10))) or ((c7 == 9))):
                        pass
                    elif (c7 == 34):
                        if ((field is not None) or comma1):
                            self.invalidChar()
                        field = self.parseString()
                    elif (c7 == 44):
                        if comma1:
                            comma1 = False
                        else:
                            self.invalidChar()
                    elif (c7 == 58):
                        if (field is None):
                            self.invalidChar()
                        value = self.parseRec()
                        setattr(obj,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)
                        field = None
                        comma1 = True
                    elif (c7 == 125):
                        if ((field is not None) or ((comma1 == False))):
                            self.invalidChar()
                        return obj
                    else:
                        self.invalidChar()
            else:
                self.invalidChar()

    def parseString(self):
        start = self.pos
        buf = None
        prev = -1
        while True:
            s = self.str
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == 34):
                break
            if (c == 92):
                if (buf is None):
                    buf = StringBuf()
                s1 = self.str
                _hx_len = ((self.pos - start) - 1)
                s2 = (HxString.substr(s1,start,None) if ((_hx_len is None)) else HxString.substr(s1,start,_hx_len))
                buf.b.write(s2)
                s3 = self.str
                index1 = self.pos
                self.pos = (self.pos + 1)
                c = (-1 if ((index1 >= len(s3))) else ord(s3[index1]))
                if ((c != 117) and ((prev != -1))):
                    s4 = "".join(map(chr,[65533]))
                    buf.b.write(s4)
                    prev = -1
                c1 = c
                if (((c1 == 92) or ((c1 == 47))) or ((c1 == 34))):
                    s5 = "".join(map(chr,[c]))
                    buf.b.write(s5)
                elif (c1 == 98):
                    s6 = "".join(map(chr,[8]))
                    buf.b.write(s6)
                elif (c1 == 102):
                    s7 = "".join(map(chr,[12]))
                    buf.b.write(s7)
                elif (c1 == 110):
                    s8 = "".join(map(chr,[10]))
                    buf.b.write(s8)
                elif (c1 == 114):
                    s9 = "".join(map(chr,[13]))
                    buf.b.write(s9)
                elif (c1 == 116):
                    s10 = "".join(map(chr,[9]))
                    buf.b.write(s10)
                elif (c1 == 117):
                    uc = Std.parseInt(("0x" + HxOverrides.stringOrNull(HxString.substr(self.str,self.pos,4))))
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.pos
                    _hx_local_0.pos = (_hx_local_1 + 4)
                    _hx_local_0.pos
                    if (prev != -1):
                        if ((uc < 56320) or ((uc > 57343))):
                            s11 = "".join(map(chr,[65533]))
                            buf.b.write(s11)
                            prev = -1
                        else:
                            s12 = "".join(map(chr,[(((((prev - 55296) << 10)) + ((uc - 56320))) + 65536)]))
                            buf.b.write(s12)
                            prev = -1
                    elif ((uc >= 55296) and ((uc <= 56319))):
                        prev = uc
                    else:
                        s13 = "".join(map(chr,[uc]))
                        buf.b.write(s13)
                else:
                    raise haxe_Exception.thrown(((("Invalid escape sequence \\" + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " at position ") + Std.string(((self.pos - 1)))))
                start = self.pos
            elif (c == -1):
                raise haxe_Exception.thrown("Unclosed string")
        if (prev != -1):
            s = "".join(map(chr,[65533]))
            buf.b.write(s)
            prev = -1
        if (buf is None):
            return HxString.substr(self.str,start,((self.pos - start) - 1))
        else:
            s = self.str
            _hx_len = ((self.pos - start) - 1)
            s1 = (HxString.substr(s,start,None) if ((_hx_len is None)) else HxString.substr(s,start,_hx_len))
            buf.b.write(s1)
            return buf.b.getvalue()

    def invalidChar(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 1)
        _hx_local_1
        s = self.str
        index = self.pos
        raise haxe_Exception.thrown(((("Invalid char " + Std.string(((-1 if ((index >= len(s))) else ord(s[index]))))) + " at position ") + Std.string(self.pos)))

    def invalidNumber(self,start):
        raise haxe_Exception.thrown(((("Invalid number at position " + Std.string(start)) + ": ") + HxOverrides.stringOrNull(HxString.substr(self.str,start,(self.pos - start)))))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.str = None
        _hx_o.pos = None
haxe_format_JsonParser._hx_class = haxe_format_JsonParser


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    _hx_is_interface = "False"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v1 = v
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                _hx_len = len(v1)
                last = (_hx_len - 1)
                _g1 = 0
                _g2 = _hx_len
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this = self.buf
                        s = "".join(map(chr,[44]))
                        _this.b.write(s)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this1 = self.buf
                        s1 = "".join(map(chr,[10]))
                        _this1.b.write(s1)
                    if self.pretty:
                        v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this2 = self.buf
                        s2 = Std.string(v2)
                        _this2.b.write(s2)
                    self.write(i,(v1[i] if i >= 0 and i < len(v1) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this3 = self.buf
                            s3 = "".join(map(chr,[10]))
                            _this3.b.write(s3)
                        if self.pretty:
                            v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this4 = self.buf
                            s4 = Std.string(v3)
                            _this4.b.write(s4)
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
            elif (c == haxe_ds_StringMap):
                v1 = v
                o = _hx_AnonObject({})
                k = v1.keys()
                while k.hasNext():
                    k1 = k.next()
                    value = v1.h.get(k1,None)
                    setattr(o,(("_hx_" + k1) if ((k1 in python_Boot.keywords)) else (("_hx_" + k1) if (((((len(k1) > 2) and ((ord(k1[0]) == 95))) and ((ord(k1[1]) == 95))) and ((ord(k1[(len(k1) - 1)]) != 95)))) else k1)),value)
                v1 = o
                self.fieldsString(v1,python_Boot.fields(v1))
            elif (c == Date):
                v1 = v
                self.quote(v1.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g1 = _g.params[0]
            i = v.index
            v = Std.string(i)
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this = self.buf
                s = "".join(map(chr,[44]))
                _this.b.write(s)
            if self.pretty:
                _this1 = self.buf
                s1 = "".join(map(chr,[10]))
                _this1.b.write(s1)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this2 = self.buf
                s2 = Std.string(v1)
                _this2.b.write(s2)
            self.quote(f)
            _this3 = self.buf
            s3 = "".join(map(chr,[58]))
            _this3.b.write(s3)
            if self.pretty:
                _this4 = self.buf
                s4 = "".join(map(chr,[32]))
                _this4.b.write(s4)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this5 = self.buf
                    s5 = "".join(map(chr,[10]))
                    _this5.b.write(s5)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this6 = self.buf
                    s6 = Std.string(v2)
                    _this6.b.write(s6)
        _this = self.buf
        s = "".join(map(chr,[125]))
        _this.b.write(s)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        length = len(s)
        while (i < length):
            index = i
            i = (i + 1)
            c = ord(s[index])
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this = self.buf
                s1 = "".join(map(chr,[c]))
                _this.b.write(s1)
        _this = self.buf
        s = "".join(map(chr,[34]))
        _this.b.write(s)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["toHex"]
    _hx_statics = ["alloc", "ofString", "ofHex"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofHex(s):
        _hx_len = len(s)
        if (((_hx_len & 1)) != 0):
            raise haxe_Exception.thrown("Not a hex string (odd number of digits)")
        ret = haxe_io_Bytes.alloc((_hx_len >> 1))
        _g = 0
        _g1 = ret.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = (i * 2)
            high = (-1 if ((index >= len(s))) else ord(s[index]))
            index1 = ((i * 2) + 1)
            low = (-1 if ((index1 >= len(s))) else ord(s[index1]))
            high = (((high & 15)) + ((((((high & 64)) >> 6)) * 9)))
            low = (((low & 15)) + ((((((low & 64)) >> 6)) * 9)))
            ret.b[i] = (((((high << 4) | low)) & 255) & 255)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["join", "normalize", "addTrailingSlash"]

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g = 0
        _g1 = len(tmp)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g3 = _g2
            if (_g3 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g2
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g3 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g2
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path
haxe_io_Path._hx_class = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class kiss__List_List_Impl_:
    _hx_class_name = "kiss._List.List_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromArray", "toArray", "realIndex", "get", "arrayWrite", "insert", "slice", "splice"]

    @staticmethod
    def _new(a):
        return a

    @staticmethod
    def fromArray(a):
        return a

    @staticmethod
    def toArray(this1):
        return this1

    @staticmethod
    def realIndex(this1,idx):
        if (idx < 0):
            return (len(this1) + idx)
        else:
            return idx

    @staticmethod
    def get(this1,idx):
        return python_internal_ArrayImpl._get(this1, ((len(this1) + idx) if ((idx < 0)) else idx))

    @staticmethod
    def arrayWrite(this1,idx,v):
        python_internal_ArrayImpl._set(this1, ((len(this1) + idx) if ((idx < 0)) else idx), v)
        return v

    @staticmethod
    def insert(this1,idx,v):
        pos = ((len(this1) + idx) if ((idx < 0)) else idx)
        this1.insert(pos, v)

    @staticmethod
    def slice(this1,start,end = None):
        if (end is None):
            end = len(this1)
        return this1[((len(this1) + start) if ((start < 0)) else start):((len(this1) + end) if ((end < 0)) else end)]

    @staticmethod
    def splice(this1,start,_hx_len):
        pos = ((len(this1) + start) if ((start < 0)) else start)
        if (pos < 0):
            pos = (len(this1) + pos)
        if (pos < 0):
            pos = 0
        res = this1[pos:(pos + _hx_len)]
        del this1[pos:(pos + _hx_len)]
        return res
kiss__List_List_Impl_._hx_class = kiss__List_List_Impl_

class kiss_ExtraElementHandling(Enum):
    __slots__ = ()
    _hx_class_name = "kiss.ExtraElementHandling"
    _hx_constructs = ["Keep", "Drop", "Throw"]
kiss_ExtraElementHandling.Keep = kiss_ExtraElementHandling("Keep", 0, ())
kiss_ExtraElementHandling.Drop = kiss_ExtraElementHandling("Drop", 1, ())
kiss_ExtraElementHandling.Throw = kiss_ExtraElementHandling("Throw", 2, ())
kiss_ExtraElementHandling._hx_class = kiss_ExtraElementHandling

class kiss_KissTarget(Enum):
    __slots__ = ()
    _hx_class_name = "kiss.KissTarget"
    _hx_constructs = ["Cpp", "CSharp", "Haxe", "JavaScript", "NodeJS", "Python", "Macro"]
kiss_KissTarget.Cpp = kiss_KissTarget("Cpp", 0, ())
kiss_KissTarget.CSharp = kiss_KissTarget("CSharp", 1, ())
kiss_KissTarget.Haxe = kiss_KissTarget("Haxe", 2, ())
kiss_KissTarget.JavaScript = kiss_KissTarget("JavaScript", 3, ())
kiss_KissTarget.NodeJS = kiss_KissTarget("NodeJS", 4, ())
kiss_KissTarget.Python = kiss_KissTarget("Python", 5, ())
kiss_KissTarget.Macro = kiss_KissTarget("Macro", 6, ())
kiss_KissTarget._hx_class = kiss_KissTarget


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "_add_dynamic", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field1) if (hasattr(o,field1)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()
sys_io_File._hx_class = sys_io_File


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator


class kiss_Prelude:
    _hx_class_name = "kiss.Prelude"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["stringOrFloat", "_and", "and", "_or", "or", "makeVarArgsWithArrayCheck", "_add", "add", "_subtract", "subtract", "_multiply2", "_multiply", "multiply", "_divide", "divide", "mod", "pow", "_min", "min", "_max", "max", "_comparison", "greaterThan", "greaterEqual", "lessThan", "lesserEqual", "areEqual", "iFraction", "iHalf", "iThird", "iFourth", "iFifth", "iSixth", "iSeventh", "iEighth", "iNinth", "iTenth", "fFraction", "fHalf", "fThird", "fFourth", "fFifth", "fSixth", "fSeventh", "fEighth", "fNinth", "fTenth", "sort", "sortBy", "groups", "_concat", "concat", "_zip", "zipKeep", "zipDrop", "zipThrow", "_intersect", "intersect", "enumerate", "pairs", "reverse", "range", "_joinPath", "joinPath", "isNull", "truthy", "chooseRandom", "memoize", "fsMemoize", "_printStr", "externLogFile", "_externPrintStr", "printStr", "withLabel", "print", "symbolNameValue", "uuid", "symbol", "symbolName", "expList", "isListExp", "kissProcess", "walkDirectory", "purgeDirectory", "convertToHScript", "userHome", "cachedConvertToHScript", "getTarget", "assertProcess", "tryProcess", "libPath", "shellCountMutex", "shellCount", "shellExecute", "filter", "readDirectory", "substr", "runtimeInsertAssertionMessage", "newLine", "backSlash", "doubleQuote", "dollar"]

    @staticmethod
    def stringOrFloat(d):
        tmp = Type.typeof(d).index
        if ((tmp == 2) or ((tmp == 1))):
            return haxe_ds_Either.Right(python_Boot._add_dynamic(0.0,d))
        elif Std.isOfType(d,str):
            return haxe_ds_Either.Left(d)
        else:
            raise haxe_Exception.thrown((("cannot use " + Std.string(d)) + " in multiplication"))

    @staticmethod
    def _and(values):
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            if (not kiss_Prelude.truthy(value)):
                return False
        return python_internal_ArrayImpl._get(values, (len(values) - 1))

    @staticmethod
    def _or(values):
        _g = 0
        while (_g < len(values)):
            value = (values[_g] if _g >= 0 and _g < len(values) else None)
            _g = (_g + 1)
            if kiss_Prelude.truthy(value):
                return value
        return python_internal_ArrayImpl._get(values, (len(values) - 1))

    @staticmethod
    def makeVarArgsWithArrayCheck(f,name):
        def _hx_local_0(args):
            if ((len(args) == 1) and Std.isOfType((args[0] if 0 < len(args) else None),list)):
                raise haxe_Exception.thrown((((((("Array " + Std.string((args[0] if 0 < len(args) else None))) + " was passed to variadic function ") + ("null" if name is None else name)) + ". Use (apply ") + ("null" if name is None else name)) + " args) instead"))
            return f(args)
        fWithArrayCheck = _hx_local_0
        return Reflect.makeVarArgs(fWithArrayCheck)

    @staticmethod
    def _add(values):
        sum = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            sum = python_Boot._add_dynamic(sum,value)
        return sum

    @staticmethod
    def _subtract(values):
        difference = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            difference = (difference - value)
        return difference

    @staticmethod
    def _multiply2(a,b):
        _g = kiss_Prelude.stringOrFloat(a)
        _g1 = kiss_Prelude.stringOrFloat(b)
        tmp = _g.index
        if (tmp == 0):
            _g2 = _g.params[0]
            tmp = _g1.index
            if (tmp == 0):
                b1 = _g1.params[0]
                a1 = _g2
                raise haxe_Exception.thrown((((("cannot multiply strings \"" + ("null" if a1 is None else a1)) + "\" and \"") + ("null" if b1 is None else b1)) + "\""))
            elif (tmp == 1):
                i = _g1.params[0]
                s = _g2
                if (HxOverrides.modf(i, 1) == 0):
                    result = ""
                    _g2 = 0
                    _g3 = Math.floor(i)
                    while (_g2 < _g3):
                        _ = _g2
                        _g2 = (_g2 + 1)
                        result = (("null" if result is None else result) + ("null" if s is None else s))
                    return result
                else:
                    raise haxe_Exception.thrown(((("cannot multiply " + Std.string(a)) + " and ") + Std.string(b)))
            else:
                raise haxe_Exception.thrown(((("cannot multiply " + Std.string(a)) + " and ") + Std.string(b)))
        elif (tmp == 1):
            _g2 = _g.params[0]
            tmp = _g1.index
            if (tmp == 0):
                s = _g1.params[0]
                i = _g2
                if (HxOverrides.modf(i, 1) == 0):
                    result = ""
                    _g = 0
                    _g3 = Math.floor(i)
                    while (_g < _g3):
                        _ = _g
                        _g = (_g + 1)
                        result = (("null" if result is None else result) + ("null" if s is None else s))
                    return result
                else:
                    raise haxe_Exception.thrown(((("cannot multiply " + Std.string(a)) + " and ") + Std.string(b)))
            elif (tmp == 1):
                f2 = _g1.params[0]
                f = _g2
                return (f * f2)
            else:
                raise haxe_Exception.thrown(((("cannot multiply " + Std.string(a)) + " and ") + Std.string(b)))
        else:
            pass

    @staticmethod
    def _multiply(values):
        product = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            product = kiss_Prelude._multiply2(product,value)
        return product

    @staticmethod
    def _divide(values):
        quotient = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            quotient = (quotient / value)
        return quotient

    @staticmethod
    def mod(top,bottom):
        return HxOverrides.modf(top, bottom)

    @staticmethod
    def pow(base,exponent):
        return Math.pow(base,exponent)

    @staticmethod
    def _min(values):
        _hx_min = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b = value
            if (not python_lib_Math.isnan(_hx_min)):
                _hx_min = (b if (python_lib_Math.isnan(b)) else min(_hx_min,b))
        return _hx_min

    @staticmethod
    def _max(values):
        _hx_max = (values[0] if 0 < len(values) else None)
        _g = 0
        _g1 = values[1:None]
        while (_g < len(_g1)):
            value = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b = value
            if (not python_lib_Math.isnan(_hx_max)):
                _hx_max = (b if (python_lib_Math.isnan(b)) else max(_hx_max,b))
        return _hx_max

    @staticmethod
    def _comparison(op,values):
        _g = 1
        _g1 = len(values)
        while (_g < _g1):
            idx = _g
            _g = (_g + 1)
            a = python_internal_ArrayImpl._get(values, (idx - 1))
            b = (values[idx] if idx >= 0 and idx < len(values) else None)
            check = None
            op1 = op
            _hx_local_0 = len(op1)
            if (_hx_local_0 == 1):
                if (op1 == "<"):
                    check = (a < b)
                elif (op1 == ">"):
                    check = (a > b)
                else:
                    raise haxe_Exception.thrown("Unreachable case")
            elif (_hx_local_0 == 2):
                if (op1 == "<="):
                    check = (a <= b)
                elif (op1 == "=="):
                    check = HxOverrides.eq(a,b)
                elif (op1 == ">="):
                    check = (a >= b)
                else:
                    raise haxe_Exception.thrown("Unreachable case")
            else:
                raise haxe_Exception.thrown("Unreachable case")
            if (not check):
                return False
        return True

    @staticmethod
    def iFraction(num,denom):
        tmp = None
        try:
            tmp = int((num / denom))
        except BaseException as _g:
            None
            tmp = None
        return tmp

    @staticmethod
    def fFraction(num,denom):
        return (num / denom)

    @staticmethod
    def sort(a,comp = None):
        if (comp is None):
            comp = Reflect.compare
        sorted = list(a)
        sorted.sort(key= python_lib_Functools.cmp_to_key(comp))
        return sorted

    @staticmethod
    def sortBy(a,index,comp = None):
        if (comp is None):
            comp = Reflect.compare
        def _hx_local_1():
            def _hx_local_0(v1,v2):
                return comp(index(v1),index(v2))
            return kiss_Prelude.sort(a,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def groups(a,size,extraHandling = None):
        if (extraHandling is None):
            extraHandling = kiss_ExtraElementHandling.Throw
        numFullGroups = Math.floor((len(a) / size))
        _g = []
        _g1 = 0
        _g2 = numFullGroups
        while (_g1 < _g2):
            num = _g1
            _g1 = (_g1 + 1)
            start = (num * size)
            end = (((num + 1)) * size)
            x = a[start:end]
            _g.append(x)
        fullGroups = _g
        if (HxOverrides.mod(len(a), size) != 0):
            tmp = extraHandling.index
            if (tmp == 0):
                x = a[(numFullGroups * size):None]
                fullGroups.append(x)
            elif (tmp == 1):
                pass
            elif (tmp == 2):
                raise haxe_Exception.thrown(((("groups was given a non-divisible number of elements: " + Std.string(a)) + ", ") + Std.string(size)))
            else:
                pass
        return fullGroups

    @staticmethod
    def _concat(arrays):
        arr = (arrays[0] if 0 < len(arrays) else None)
        _g = 0
        _g1 = arrays[1:None]
        while (_g < len(_g1)):
            nextArr = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            arr = (arr + nextArr)
        return arr

    @staticmethod
    def _zip(iterables,extraHandling):
        lists = []
        _g = []
        _g1 = 0
        while (_g1 < len(iterables)):
            iterable = (iterables[_g1] if _g1 >= 0 and _g1 < len(iterables) else None)
            _g1 = (_g1 + 1)
            x = Reflect.field(iterable,"iterator")()
            _g.append(x)
        iterators = _g
        while True:
            zipped = []
            someNonNull = False
            _g = 0
            while (_g < len(iterators)):
                it = (iterators[_g] if _g >= 0 and _g < len(iterators) else None)
                _g = (_g + 1)
                if (extraHandling.index == 0):
                    x = None
                    if it.hasNext():
                        someNonNull = True
                        x = it.next()
                    else:
                        x = None
                    zipped.append(x)
                elif it.hasNext():
                    x1 = it.next()
                    zipped.append(x1)
            if (len(zipped) == 0):
                break
            else:
                tmp = extraHandling.index
                if (tmp == 0):
                    if (not someNonNull):
                        break
                elif (tmp == 1):
                    if (len(zipped) != len(iterators)):
                        break
                elif (tmp == 2):
                    if (len(zipped) != len(iterators)):
                        raise haxe_Exception.thrown(((("zip" + Std.string(extraHandling)) + " was given iterables of mis-matched size: ") + Std.string(iterables)))
                else:
                    pass
            lists.append(zipped)
        return lists

    @staticmethod
    def _intersect(iterables):
        _g = []
        _g1 = 0
        while (_g1 < len(iterables)):
            iterable = (iterables[_g1] if _g1 >= 0 and _g1 < len(iterables) else None)
            _g1 = (_g1 + 1)
            x = Reflect.field(iterable,"iterator")()
            _g.append(x)
        iterators = _g
        _g = []
        elem = (None if ((len(iterators) == 0)) else iterators.pop(0))
        while elem.hasNext():
            elem1 = elem.next()
            _g.append([elem1])
        intersections = _g
        _g = 0
        while (_g < len(iterators)):
            iterator = (iterators[_g] if _g >= 0 and _g < len(iterators) else None)
            _g = (_g + 1)
            _g1 = []
            elem = iterator
            while elem.hasNext():
                elem1 = elem.next()
                _g2 = []
                _g3 = 0
                while (_g3 < len(intersections)):
                    intersection = (intersections[_g3] if _g3 >= 0 and _g3 < len(intersections) else None)
                    _g3 = (_g3 + 1)
                    x = (intersection + [elem1])
                    _g2.append(x)
                _g1.append(_g2)
            intersections = kiss_Prelude._concat(_g1)
        return intersections

    @staticmethod
    def enumerate(l,startingIdx = None):
        if (startingIdx is None):
            startingIdx = 0
        return kiss_Prelude.zipThrow(kiss_Prelude.range(startingIdx,(startingIdx + len(l)),1),l)

    @staticmethod
    def pairs(l,loopAround = None):
        if (loopAround is None):
            loopAround = False
        l1 = kiss__List_List_Impl_.slice(l,0,(len(l) - 1))
        l2 = kiss__List_List_Impl_.slice(l,1,len(l))
        if loopAround:
            x = python_internal_ArrayImpl._get(l, (len(l) + (-1)))
            l1.append(x)
            l2.insert(0, python_internal_ArrayImpl._get(l, 0))
        return kiss_Prelude.zipThrow(l1,l2)

    @staticmethod
    def reverse(l):
        c = list(l)
        c.reverse()
        return c

    @staticmethod
    def range(_hx_min,_hx_max,step):
        if ((step <= 0) or ((_hx_max < _hx_min))):
            raise haxe_Exception.thrown("(range...) can only count up")
        count = _hx_min
        def _hx_local_1():
            nonlocal count
            oldCount = count
            count = (count + step)
            return oldCount
        def _hx_local_2():
            return (count < _hx_max)
        iterator = _hx_AnonObject({'next': _hx_local_1, 'hasNext': _hx_local_2})
        def _hx_local_6():
            def _hx_local_3():
                return iterator
            def _hx_local_4():
                return iterator.next()
            def _hx_local_5():
                return iterator.hasNext()
            return _hx_AnonObject({'iterator': _hx_local_3, 'next': _hx_local_4, 'hasNext': _hx_local_5})
        return _hx_local_6()

    @staticmethod
    def _joinPath(parts):
        _g = []
        _g1 = 0
        while (_g1 < len(parts)):
            part = (parts[_g1] if _g1 >= 0 and _g1 < len(parts) else None)
            _g1 = (_g1 + 1)
            def _hx_local_2():
                _hx_local_1 = part
                if (Std.isOfType(_hx_local_1,str) or ((_hx_local_1 is None))):
                    _hx_local_1
                else:
                    raise "Class cast error"
                return _hx_local_1
            _g.append(_hx_local_2())
        return haxe_io_Path.join(_g)

    @staticmethod
    def isNull(v):
        if (Type.typeof(v).index == 0):
            return True
        else:
            return False

    @staticmethod
    def truthy(v):
        tmp = Type.typeof(v).index
        if (tmp == 0):
            return False
        elif (tmp == 3):
            def _hx_local_2():
                def _hx_local_1():
                    _hx_local_0 = v
                    if (Std.isOfType(_hx_local_0,Bool) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                return _hx_local_1()
            return _hx_local_2()
        elif Std.isOfType(v,str):
            _hx_str = v
            return (len(_hx_str) > 0)
        elif Std.isOfType(v,list):
            lst = v
            return (len(lst) > 0)
        else:
            return True

    @staticmethod
    def chooseRandom(l):
        x = len(l)
        idx = (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))
        return python_internal_ArrayImpl._get(l, ((len(l) + idx) if ((idx < 0)) else idx))

    @staticmethod
    def memoize(func,caller = None,jsonFile = None,jsonArgMap = None):
        argMap = (jsonArgMap if ((jsonArgMap is not None)) else haxe_ds_StringMap())
        def _hx_local_0(args):
            argString = "|".join([python_Boot.toString1(x1,'') for x1 in args])
            if (argString in argMap.h):
                return argMap.h.get(argString,None)
            else:
                ret = Reflect.callMethod(caller,func,args)
                argMap.h[argString] = ret
                if (jsonFile is not None):
                    sys_io_File.saveContent(jsonFile,haxe_format_JsonPrinter.print(argMap,None,None))
                return ret
        f = _hx_local_0
        f = Reflect.makeVarArgs(f)
        return f

    @staticmethod
    def fsMemoize(func,funcName,cacheDirectory = None,caller = None):
        if (cacheDirectory is None):
            cacheDirectory = ""
        fileName = (("" + ("null" if funcName is None else funcName)) + ".memoized")
        if (len(cacheDirectory) > 0):
            sys_FileSystem.createDirectory(cacheDirectory)
            fileName = ((("" + ("null" if cacheDirectory is None else cacheDirectory)) + "/") + ("null" if fileName is None else fileName))
        if (not sys_FileSystem.exists(fileName)):
            sys_io_File.saveContent(fileName,"{}")
        pastResults = python_lib_Json.loads(sys_io_File.getContent(fileName),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        _g = haxe_ds_StringMap()
        access = pastResults
        _g_access = access
        _g_keys = python_Boot.fields(access)
        _g_index = 0
        while (_g_index < len(_g_keys)):
            key = _g_index
            _g_index = (_g_index + 1)
            key1 = (_g_keys[key] if key >= 0 and key < len(_g_keys) else None)
            _g_value = Reflect.field(_g_access,key1)
            _g_key = key1
            key2 = _g_key
            value = _g_value
            _g.h[key2] = value
        argMap = _g
        return kiss_Prelude.memoize(func,caller,fileName,argMap)

    @staticmethod
    def _printStr(s):
        _hx_str = Std.string(s)
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    @staticmethod
    def _externPrintStr(s):
        logContent = None
        try:
            logContent = sys_io_File.getContent(kiss_Prelude.externLogFile)
        except BaseException as _g:
            logContent = ""
        sys_io_File.saveContent(kiss_Prelude.externLogFile,((("" + ("null" if logContent is None else logContent)) + ("null" if s is None else s)) + "\n"))

    @staticmethod
    def withLabel(v,label = None):
        if (label is None):
            label = ""
        toPrint = label
        if (len(label) > 0):
            toPrint = (("null" if toPrint is None else toPrint) + ": ")
        toPrint = (("null" if toPrint is None else toPrint) + HxOverrides.stringOrNull(("null" if ((v is None)) else Std.string(v))))
        return toPrint

    @staticmethod
    def print(v,label = None):
        if (label is None):
            label = ""
        toPrint = kiss_Prelude.withLabel(v,label)
        kiss_Prelude.printStr(toPrint)
        return v

    @staticmethod
    def symbolNameValue(s,allowTyped = None,allowMeta = None):
        if (allowTyped is None):
            allowTyped = False
        if (allowMeta is None):
            allowMeta = False
        _g = s._hx_def
        tmp = _g.index
        if (tmp == 3):
            name = _g.params[0]
            return name
        elif (tmp == 6):
            _g1 = _g.params[0]
            innerExp = _g.params[1]
            if allowTyped:
                return kiss_Prelude.symbolNameValue(innerExp,False)
            else:
                raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))
        elif (tmp == 7):
            _g1 = _g.params[0]
            innerExp = _g.params[1]
            if allowMeta:
                return kiss_Prelude.symbolNameValue(innerExp,allowTyped,False)
            else:
                raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))
        else:
            raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))

    @staticmethod
    def uuid():
        return uuid_Uuid.toShort(uuid_Uuid.v4())

    @staticmethod
    def symbol(name = None):
        if (name is None):
            name = ("_" + HxOverrides.stringOrNull(uuid_Uuid.toShort(uuid_Uuid.v4())))
        return kiss_ReaderExpDef.Symbol(name)

    @staticmethod
    def symbolName(s,allowTyped = None,allowMeta = None):
        if (allowTyped is None):
            allowTyped = False
        if (allowMeta is None):
            allowMeta = False
        _g = s._hx_def
        tmp = _g.index
        if (tmp == 3):
            name = _g.params[0]
            return kiss_ReaderExpDef.StrExp(name)
        elif (tmp == 6):
            _g1 = _g.params[0]
            innerExp = _g.params[1]
            if allowTyped:
                return kiss_Prelude.symbolName(innerExp,False)
            else:
                raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))
        elif (tmp == 7):
            _g1 = _g.params[0]
            innerExp = _g.params[1]
            if allowMeta:
                return kiss_Prelude.symbolName(innerExp,allowTyped,False)
            else:
                raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))
        else:
            raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a plain symbol"))

    @staticmethod
    def expList(s):
        _g = s._hx_def
        if (_g.index == 1):
            exps = _g.params[0]
            return exps
        else:
            raise haxe_Exception.thrown((("expected " + Std.string(s)) + " to be a list expression"))

    @staticmethod
    def isListExp(s):
        _g = s._hx_def
        if (_g.index == 1):
            exps = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def walkDirectory(basePath,directory,processFile,filterFolderBefore = None,processFolderAfter = None):
        _g = 0
        _g1 = sys_FileSystem.readDirectory(kiss_Prelude.joinPath(basePath,directory))
        while (_g < len(_g1)):
            fileOrFolder = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            folder = fileOrFolder
            if sys_FileSystem.isDirectory(kiss_Prelude.joinPath(basePath,directory,folder)):
                subdirectory = kiss_Prelude.joinPath(directory,folder)
                if (filterFolderBefore is not None):
                    if filterFolderBefore(subdirectory):
                        continue
                kiss_Prelude.walkDirectory(basePath,subdirectory,processFile,filterFolderBefore,processFolderAfter)
                if (processFolderAfter is not None):
                    processFolderAfter(subdirectory)
            else:
                file = fileOrFolder
                processFile(kiss_Prelude.joinPath(directory,file))

    @staticmethod
    def purgeDirectory(directory):
        kiss_Prelude.walkDirectory("",directory,sys_FileSystem.deleteFile,None,sys_FileSystem.deleteDirectory)
        sys_FileSystem.deleteDirectory(directory)

    @staticmethod
    def convertToHScript(kissStr):
        hscript = None
        try:
            hscript = kiss_Prelude.assertProcess("haxelib",["run", "kiss", "convert", "--hscript"],[StringTools.replace(kissStr,"\n"," ")],False)
        except BaseException as _g:
            e = haxe_Exception.caught(_g)
            raise haxe_Exception.thrown(((("failed to convert " + ("null" if kissStr is None else kissStr)) + " to hscript:\n") + Std.string(e)))
        if hscript.startswith(">>> "):
            hscript = HxString.substr(hscript,4,None)
        return StringTools.trim(hscript)

    @staticmethod
    def userHome():
        msysHome = Sys.getEnv("MSYSHOME")
        home = Sys.getEnv("HOME")
        userProfile = Sys.getEnv("UserProfile")
        if (msysHome is not None):
            return msysHome
        elif (home is not None):
            return home
        elif (userProfile is not None):
            return userProfile
        else:
            raise haxe_Exception.thrown("Cannot find user's home directory")

    @staticmethod
    def getTarget():
        return kiss_KissTarget.Python

    @staticmethod
    def assertProcess(command,args,inputLines = None,fullProcess = None,cwd = None):
        if (fullProcess is None):
            fullProcess = True
        def _hx_local_1():
            def _hx_local_0(error):
                raise haxe_Exception.thrown(error)
            return kiss_Prelude.tryProcess(command,args,_hx_local_0,inputLines,fullProcess,cwd)
        return _hx_local_1()

    @staticmethod
    def tryProcess(command,args,handleError,inputLines = None,fullProcess = None,cwd = None):
        if (fullProcess is None):
            fullProcess = True
        if (inputLines is not None):
            _g = 0
            while (_g < len(inputLines)):
                line = (inputLines[_g] if _g >= 0 and _g < len(inputLines) else None)
                _g = (_g + 1)
                startIndex = None
                if (((line.find("\n") if ((startIndex is None)) else HxString.indexOfImpl(line,"\n",startIndex))) != -1):
                    handleError((("newline is not allowed in the middle of a process input line: \"" + HxOverrides.stringOrNull(StringTools.replace(line,"\n","\n"))) + "\""))
                    return None
        p = None
        try:
            args1 = ([command] + args)
            o = _hx_AnonObject({'stdin': -1, 'stdout': -1, 'stderr': -1, 'cwd': cwd})
            Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (python_Boot.hasField(o,"bufsize")) else 0))
            Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (python_Boot.hasField(o,"executable")) else None))
            Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (python_Boot.hasField(o,"stdin")) else None))
            Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (python_Boot.hasField(o,"stdout")) else None))
            Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (python_Boot.hasField(o,"stderr")) else None))
            Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (python_Boot.hasField(o,"preexec_fn")) else None))
            Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (python_Boot.hasField(o,"close_fds")) else None))
            Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (python_Boot.hasField(o,"shell")) else None))
            Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (python_Boot.hasField(o,"cwd")) else None))
            Reflect.setField(o,"env",(Reflect.field(o,"env") if (python_Boot.hasField(o,"env")) else None))
            Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (python_Boot.hasField(o,"universal_newlines")) else None))
            Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (python_Boot.hasField(o,"startupinfo")) else None))
            Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (python_Boot.hasField(o,"creationflags")) else 0))
            p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            handleError(Std.string(e))
            return None
        if (inputLines is not None):
            _g = 0
            while (_g < len(inputLines)):
                line = (inputLines[_g] if _g >= 0 and _g < len(inputLines) else None)
                _g = (_g + 1)
                p.stdin.write(bytearray((("" + ("null" if line is None else line)) + "\n"),"utf-8"))
        output = None
        if fullProcess:
            if (p.wait() == 0):
                output = StringTools.trim(p.stdout.readall().decode())
            else:
                handleError(((((("process " + ("null" if command is None else command)) + " ") + Std.string(args)) + " failed:\n") + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(StringTools.trim(p.stdout.readall().decode())) + HxOverrides.stringOrNull(StringTools.trim(p.stderr.readall().decode())))))))
                return None
        else:
            _hx_bytes = p.stdout.readline()
            s = Reflect.field(_hx_bytes,"decode")()
            output = StringTools.trim(s)
        p.terminate()
        return output

    @staticmethod
    def libPath(haxelibName):
        return StringTools.trim(kiss_Prelude.assertProcess("haxelib",["libpath", haxelibName]))

    @staticmethod
    def shellExecute(script,shell):
        if (len(shell) == 0):
            shell = ("cmd /c" if ((Sys.systemName() == "Windows")) else "bash")
        kiss_Prelude.shellCountMutex.lock.acquire(True)
        def _hx_local_2():
            _hx_local_0 = kiss_Prelude
            _hx_local_1 = _hx_local_0.shellCount
            _hx_local_0.shellCount = (_hx_local_1 + 1)
            return _hx_local_1
        tempScript = ("tempScript" + Std.string(_hx_local_2()))
        tempScript1 = ((("null" if tempScript is None else tempScript) + ".") + HxOverrides.stringOrNull(HxOverrides.arrayGet(shell.split(" "), 0)))
        kiss_Prelude.shellCountMutex.lock.release()
        sys_io_File.saveContent(tempScript1,script)
        try:
            if (Sys.systemName() != "Windows"):
                tempScript1 = kiss_Prelude.joinPath(Sys.getCwd(),tempScript1)
            parts = (shell.split(" ") + [tempScript1])
            shell = (None if ((len(parts) == 0)) else parts.pop(0))
            kiss_Prelude.assertProcess(shell,parts)
            sys_FileSystem.deleteFile(tempScript1)
        except BaseException as _g:
            e = haxe_Exception.caught(_g)
            kiss_Prelude.printStr("# Failing script:")
            kiss_Prelude.printStr(script)
            kiss_Prelude.printStr("#################")
            sys_FileSystem.deleteFile(tempScript1)
            raise haxe_Exception.thrown(e)

    @staticmethod
    def filter(l,p = None):
        if (p is None):
            p = kiss_Prelude.truthy
        return Lambda.filter(l,p)

    @staticmethod
    def readDirectory(dir):
        _g = []
        _g1 = 0
        _g2 = sys_FileSystem.readDirectory(dir)
        while (_g1 < len(_g2)):
            file = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = kiss_Prelude.joinPath(dir,file)
            _g.append(x)
        return _g

    @staticmethod
    def substr(_hx_str,startIdx,endIdx = None):
        def _hx_local_0(idx):
            if (idx < 0):
                return (len(_hx_str) + idx)
            else:
                return idx
        negIdx = _hx_local_0
        if (endIdx is None):
            endIdx = len(_hx_str)
        startIndex = negIdx(startIdx)
        endIndex = negIdx(endIdx)
        return HxString.substring(_hx_str,startIndex,endIndex)

    @staticmethod
    def runtimeInsertAssertionMessage(message,error,colonsInPrefix):
        colonIdx = 0
        _g = 0
        _g1 = colonsInPrefix
        while (_g < _g1):
            _ = _g
            _g = (_g + 1)
            colonIdx = (((error.find(":") if ((colonIdx is None)) else HxString.indexOfImpl(error,":",colonIdx))) + 1)
        colonIdx = (colonIdx + 1)
        return ((HxOverrides.stringOrNull(HxString.substr(error,0,colonIdx)) + ("null" if message is None else message)) + HxOverrides.stringOrNull(HxString.substr(error,colonIdx,None)))
kiss_Prelude._hx_class = kiss_Prelude

class kiss_ReaderExpDef(Enum):
    __slots__ = ()
    _hx_class_name = "kiss.ReaderExpDef"
    _hx_constructs = ["CallExp", "ListExp", "StrExp", "Symbol", "RawHaxe", "RawHaxeBlock", "TypedExp", "MetaExp", "FieldExp", "KeyValueExp", "Quasiquote", "Unquote", "UnquoteList", "ListEatingExp", "ListRestExp", "TypeParams", "HaxeMeta", "None"]

    @staticmethod
    def CallExp(func,args):
        return kiss_ReaderExpDef("CallExp", 0, (func,args))

    @staticmethod
    def ListExp(exps):
        return kiss_ReaderExpDef("ListExp", 1, (exps,))

    @staticmethod
    def StrExp(s):
        return kiss_ReaderExpDef("StrExp", 2, (s,))

    @staticmethod
    def Symbol(name):
        return kiss_ReaderExpDef("Symbol", 3, (name,))

    @staticmethod
    def RawHaxe(code):
        return kiss_ReaderExpDef("RawHaxe", 4, (code,))

    @staticmethod
    def RawHaxeBlock(code):
        return kiss_ReaderExpDef("RawHaxeBlock", 5, (code,))

    @staticmethod
    def TypedExp(path,exp):
        return kiss_ReaderExpDef("TypedExp", 6, (path,exp))

    @staticmethod
    def MetaExp(meta,exp):
        return kiss_ReaderExpDef("MetaExp", 7, (meta,exp))

    @staticmethod
    def FieldExp(field,exp):
        return kiss_ReaderExpDef("FieldExp", 8, (field,exp))

    @staticmethod
    def KeyValueExp(key,value):
        return kiss_ReaderExpDef("KeyValueExp", 9, (key,value))

    @staticmethod
    def Quasiquote(exp):
        return kiss_ReaderExpDef("Quasiquote", 10, (exp,))

    @staticmethod
    def Unquote(exp):
        return kiss_ReaderExpDef("Unquote", 11, (exp,))

    @staticmethod
    def UnquoteList(exp):
        return kiss_ReaderExpDef("UnquoteList", 12, (exp,))

    @staticmethod
    def ListEatingExp(exps):
        return kiss_ReaderExpDef("ListEatingExp", 13, (exps,))

    @staticmethod
    def ListRestExp(name):
        return kiss_ReaderExpDef("ListRestExp", 14, (name,))

    @staticmethod
    def TypeParams(types):
        return kiss_ReaderExpDef("TypeParams", 15, (types,))

    @staticmethod
    def HaxeMeta(name,params,exp):
        return kiss_ReaderExpDef("HaxeMeta", 16, (name,params,exp))
kiss_ReaderExpDef._hx_None = kiss_ReaderExpDef("None", 17, ())
kiss_ReaderExpDef._hx_class = kiss_ReaderExpDef


class kiss_StreamError:
    _hx_class_name = "kiss.StreamError"
    _hx_is_interface = "False"
    __slots__ = ("position", "message")
    _hx_fields = ["position", "message"]
    _hx_methods = ["toString"]

    def __init__(self,position,message):
        self.position = position
        self.message = message

    def toString(self):
        return (("\nKiss reader error!\n" + HxOverrides.stringOrNull(kiss_Stream.toPrint(self.position))) + HxOverrides.stringOrNull((((": " + HxOverrides.stringOrNull(self.message)) + "\n"))))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.position = None
        _hx_o.message = None
kiss_StreamError._hx_class = kiss_StreamError


class kiss_Stream:
    _hx_class_name = "kiss.Stream"
    _hx_is_interface = "False"
    __slots__ = ("content", "file", "line", "column", "absoluteChar", "absolutePerNewline", "startOfLine", "lineLengths")
    _hx_fields = ["content", "file", "line", "column", "absoluteChar", "absolutePerNewline", "startOfLine", "lineLengths"]
    _hx_methods = ["peekChars", "isEmpty", "position", "startsWith", "dropChars", "putBackString", "takeChars", "dropString", "dropStringIf", "dropUntil", "dropWhitespace", "takeUntilOneOf", "takeUntil", "takeUntilAndDrop", "takeBetween", "takeRest", "takeLine", "takeLineAsStream", "expect"]
    _hx_statics = ["fromFile", "fromString", "toPrint", "error"]

    def __init__(self,file,content):
        self.lineLengths = []
        self.startOfLine = True
        self.absolutePerNewline = 1
        self.file = StringTools.replace(file,"\\","/")
        startIndex = None
        if (((content.find("\r") if ((startIndex is None)) else HxString.indexOfImpl(content,"\r",startIndex))) >= 0):
            self.absolutePerNewline = 2
            content = StringTools.replace(content,"\r","")
        index = (len(content) - 1)
        if ((("" if (((index < 0) or ((index >= len(content))))) else content[index])) != "\n"):
            content = (("null" if content is None else content) + "\n")
        self.content = content
        self.line = 1
        self.column = 1
        self.absoluteChar = 0

    def peekChars(self,chars):
        if (len(self.content) < chars):
            return haxe_ds_Option._hx_None
        return haxe_ds_Option.Some(HxString.substr(self.content,0,chars))

    def isEmpty(self):
        return (len(self.content) == 0)

    def position(self):
        return _hx_AnonObject({'file': self.file, 'line': self.line, 'column': self.column, 'absoluteChar': self.absoluteChar})

    def startsWith(self,s):
        _g = self.peekChars(len(s))
        if (_g.index == 0):
            s1 = _g.params[0]
            if (s == s1):
                return True
            else:
                return False
        else:
            return False

    def dropChars(self,count):
        _g = 0
        _g1 = count
        while (_g < _g1):
            idx = _g
            _g = (_g + 1)
            _this = self.content
            _g2 = ("" if (((idx < 0) or ((idx >= len(_this))))) else _this[idx])
            if (_g2 == "\n"):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.absoluteChar
                _hx_local_0.absoluteChar = (_hx_local_1 + self.absolutePerNewline)
                _hx_local_0.absoluteChar
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.line
                _hx_local_2.line = (_hx_local_3 + 1)
                _hx_local_2.line
                _this1 = self.lineLengths
                x = self.column
                _this1.append(x)
                self.column = 1
                self.startOfLine = True
            else:
                c = _g2
                if (StringTools.trim(c) == ""):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.absoluteChar
                    _hx_local_4.absoluteChar = (_hx_local_5 + 1)
                    _hx_local_4.absoluteChar
                    _hx_local_6 = self
                    _hx_local_7 = _hx_local_6.column
                    _hx_local_6.column = (_hx_local_7 + 1)
                    _hx_local_6.column
                else:
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.absoluteChar
                    _hx_local_8.absoluteChar = (_hx_local_9 + 1)
                    _hx_local_8.absoluteChar
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.column
                    _hx_local_10.column = (_hx_local_11 + 1)
                    _hx_local_10.column
                    self.startOfLine = False
        self.content = HxString.substr(self.content,count,None)

    def putBackString(self,s):
        idx = (len(s) - 1)
        while (idx >= 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.absoluteChar
            _hx_local_0.absoluteChar = (_hx_local_1 - 1)
            _hx_local_0.absoluteChar
            if ((("" if (((idx < 0) or ((idx >= len(s))))) else s[idx])) == "\n"):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.line
                _hx_local_2.line = (_hx_local_3 - 1)
                _hx_local_2.line
                _this = self.lineLengths
                self.column = (None if ((len(_this) == 0)) else _this.pop())
            else:
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.column
                _hx_local_4.column = (_hx_local_5 - 1)
                _hx_local_4.column
            idx = (idx - 1)
        self.content = (("null" if s is None else s) + HxOverrides.stringOrNull(self.content))

    def takeChars(self,count):
        if (count > len(self.content)):
            return haxe_ds_Option._hx_None
        toReturn = HxString.substr(self.content,0,count)
        self.dropChars(count)
        return haxe_ds_Option.Some(toReturn)

    def dropString(self,s):
        toDrop = HxString.substr(self.content,0,len(s))
        if (toDrop != s):
            kiss_Stream.error(self,("Expected " + ("null" if s is None else s)))
        self.dropChars(len(s))

    def dropStringIf(self,s):
        toDrop = HxString.substr(self.content,0,len(s))
        if (toDrop == s):
            self.dropString(toDrop)
            return True
        return False

    def dropUntil(self,s):
        _this = self.content
        startIndex = None
        self.dropChars((_this.find(s) if ((startIndex is None)) else HxString.indexOfImpl(_this,s,startIndex)))

    def dropWhitespace(self):
        trimmed = StringTools.ltrim(self.content)
        self.dropChars((len(self.content) - len(trimmed)))

    def takeUntilOneOf(self,terminators,allowEOF = None):
        if (allowEOF is None):
            allowEOF = False
        _g = []
        _g1 = 0
        while (_g1 < len(terminators)):
            term = (terminators[_g1] if _g1 >= 0 and _g1 < len(terminators) else None)
            _g1 = (_g1 + 1)
            _this = self.content
            startIndex = None
            x = (_this.find(term) if ((startIndex is None)) else HxString.indexOfImpl(_this,term,startIndex))
            _g.append(x)
        def _hx_local_1(idx):
            return (idx >= 0)
        indices = list(filter(_hx_local_1,_g))
        if (len(indices) == 0):
            if allowEOF:
                return haxe_ds_Option.Some(self.takeRest())
            else:
                return haxe_ds_Option._hx_None
        firstIndex = Math.floor(Lambda.fold(indices,_Math_Math_Impl_.min,(indices[0] if 0 < len(indices) else None)))
        return self.takeChars(firstIndex)

    def takeUntil(self,s,allowEOF = None):
        if (allowEOF is None):
            allowEOF = False
        return self.takeUntilOneOf([s],allowEOF)

    def takeUntilAndDrop(self,s,allowEOF = None):
        if (allowEOF is None):
            allowEOF = False
        _this = self.content
        startIndex = None
        idx = (_this.find(s) if ((startIndex is None)) else HxString.indexOfImpl(_this,s,startIndex))
        if (idx < 0):
            if allowEOF:
                return haxe_ds_Option.Some(self.takeRest())
            else:
                return haxe_ds_Option._hx_None
        toReturn = HxString.substr(self.content,0,idx)
        self.dropChars((len(toReturn) + len(s)))
        return haxe_ds_Option.Some(toReturn)

    def takeBetween(self,open,close,escapeSeq = None):
        if (not self.startsWith(open)):
            return haxe_ds_Option._hx_None
        self.dropString(open)
        taken = ""
        while True:
            if self.startsWith(close):
                self.dropString(close)
                return haxe_ds_Option.Some(taken)
            elif self.startsWith(open):
                kiss_Stream.error(self,"takeBetween() does not support nested delimiter pairs")
            elif ((escapeSeq is not None) and self.startsWith(escapeSeq)):
                self.dropString(escapeSeq)
                if self.startsWith(open):
                    self.dropString(open)
                    taken = (("null" if taken is None else taken) + ("null" if open is None else open))
                elif self.startsWith(close):
                    self.dropString(close)
                    taken = (("null" if taken is None else taken) + ("null" if close is None else close))
                elif self.startsWith(escapeSeq):
                    self.dropString(escapeSeq)
                    taken = (("null" if taken is None else taken) + ("null" if escapeSeq is None else escapeSeq))
                else:
                    kiss_Stream.error(self,"invalid escape sequence")
            else:
                next = None
                _g = self.takeChars(1)
                if (_g.index == 0):
                    n = _g.params[0]
                    next = n
                else:
                    kiss_Stream.error(self,("Ran out of characters before closing delimiter " + ("null" if close is None else close)))
                    next = ""
                taken = (("null" if taken is None else taken) + ("null" if next is None else next))

    def takeRest(self):
        toReturn = self.content
        self.dropChars(len(self.content))
        return toReturn

    def takeLine(self):
        _g = self.takeUntilAndDrop("\n")
        tmp = _g.index
        if (tmp == 0):
            line = _g.params[0]
            return haxe_ds_Option.Some(line)
        elif (tmp == 1):
            if (len(self.content) > 0):
                return haxe_ds_Option.Some(self.takeRest())
            else:
                return haxe_ds_Option._hx_None
        else:
            return haxe_ds_Option._hx_None

    def takeLineAsStream(self):
        lineNo = self.line
        column = self.column
        absoluteChar = self.absoluteChar
        _g = self.takeLine()
        if (_g.index == 0):
            line = _g.params[0]
            s = kiss_Stream.fromString(line)
            s.line = lineNo
            s.column = column
            s.file = self.file
            s.absoluteChar = absoluteChar
            return haxe_ds_Option.Some(s)
        else:
            return haxe_ds_Option._hx_None

    def expect(self,whatToExpect,f):
        position = self.position()
        _g = f()
        if (_g.index == 0):
            s = _g.params[0]
            return s
        else:
            kiss_Stream.error(self,("Expected " + ("null" if whatToExpect is None else whatToExpect)))
            return None

    @staticmethod
    def fromFile(file):
        return kiss_Stream(file,sys_io_File.getContent(file))

    @staticmethod
    def fromString(content,position = None):
        file = "string"
        if (position is not None):
            file = position.file
        s = kiss_Stream(file,content)
        if (position is not None):
            s.line = position.line
            s.column = position.column
            s.absoluteChar = position.absoluteChar
        return s

    @staticmethod
    def toPrint(p):
        return ((((("" + HxOverrides.stringOrNull(p.file)) + ":") + Std.string(p.line)) + ":") + Std.string(p.column))

    @staticmethod
    def error(stream,message):
        raise haxe_Exception.thrown(kiss_StreamError(stream.position(),message))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.content = None
        _hx_o.file = None
        _hx_o.line = None
        _hx_o.column = None
        _hx_o.absoluteChar = None
        _hx_o.absolutePerNewline = None
        _hx_o.startOfLine = None
        _hx_o.lineLengths = None
kiss_Stream._hx_class = kiss_Stream


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "rshift", "modf", "mod", "arrayGet", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class requests_externs_Requests:
    _hx_class_name = "requests_externs.Requests"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get", "mapToDict", "kwArgsToNativeKwArgs"]

    @staticmethod
    def get(url,params,kwArgs = None):
        return requests_externs_NativeRequests.get(url,requests_externs_Requests.mapToDict(params),**python__KwArgs_KwArgs_Impl_.fromT(requests_externs_Requests.kwArgsToNativeKwArgs(kwArgs)))

    @staticmethod
    def mapToDict(_hx_map = None):
        if (_hx_map is None):
            return None
        _hx_dict = dict()
        map1 = _hx_map
        _g_map = map1
        _g_keys = map1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = _g_map.get(key)
            _g_key = key
            key1 = _g_key
            value = _g_value
            _hx_dict[key1] = value
        return _hx_dict

    @staticmethod
    def kwArgsToNativeKwArgs(kwArgs = None):
        if (kwArgs is None):
            return None
        return _hx_AnonObject({'headers': requests_externs_Requests.mapToDict(Reflect.field(kwArgs,"headers")), 'timeout': Reflect.field(kwArgs,"timeout")})
requests_externs_Requests._hx_class = requests_externs_Requests


class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    _hx_is_interface = "False"
    __slots__ = ()
sys_io_Process._hx_class = sys_io_Process


class sys_thread__EventLoop_RegularEvent:
    _hx_class_name = "sys.thread._EventLoop.RegularEvent"
    _hx_is_interface = "False"
    __slots__ = ("nextRunTime", "interval", "run", "next", "previous", "cancelled")
    _hx_fields = ["nextRunTime", "interval", "run", "next", "previous", "cancelled"]

    def __init__(self,run,nextRunTime,interval):
        self.previous = None
        self.next = None
        self.cancelled = False
        self.run = run
        self.nextRunTime = nextRunTime
        self.interval = interval

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nextRunTime = None
        _hx_o.interval = None
        _hx_o.run = None
        _hx_o.next = None
        _hx_o.previous = None
        _hx_o.cancelled = None
sys_thread__EventLoop_RegularEvent._hx_class = sys_thread__EventLoop_RegularEvent


class sys_thread_Lock:
    _hx_class_name = "sys.thread.Lock"
    _hx_is_interface = "False"
    __slots__ = ("semaphore",)
    _hx_fields = ["semaphore"]

    def __init__(self):
        self.semaphore = python_lib_threading_Semaphore(0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.semaphore = None
sys_thread_Lock._hx_class = sys_thread_Lock


class sys_thread_NoEventLoopException(haxe_Exception):
    _hx_class_name = "sys.thread.NoEventLoopException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,msg = None,previous = None):
        if (msg is None):
            msg = "Event loop is not available. Refer to sys.thread.Thread.runWithEventLoop."
        super().__init__(msg,previous)
sys_thread_NoEventLoopException._hx_class = sys_thread_NoEventLoopException


class sys_thread__Thread_Thread_Impl_:
    _hx_class_name = "sys.thread._Thread.Thread_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_events", "processEvents"]
    events = None

    @staticmethod
    def get_events(this1):
        if (this1.events is None):
            raise sys_thread_NoEventLoopException()
        return this1.events

    @staticmethod
    def processEvents():
        sys_thread__Thread_HxThread.current().events.loop()
sys_thread__Thread_Thread_Impl_._hx_class = sys_thread__Thread_Thread_Impl_


class tink_Json:
    _hx_class_name = "tink.Json"
    _hx_is_interface = "False"
    __slots__ = ()
tink_Json._hx_class = tink_Json


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    _hx_is_interface = "False"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        self.target = target
        self.registry = haxe_ds_ObjectMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.target = None
        _hx_o.registry = None
tink_core_Annex._hx_class = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        return f

    @staticmethod
    def toFunction(this1):
        return this1

    @staticmethod
    def invoke(this1,data):
        if (tink_core__Callback_Callback_Impl_.depth < 100):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            this1(data)
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            def _hx_local_4():
                this1(data)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_4)

    @staticmethod
    def fromNiladic(f):
        def _hx_local_0(_):
            f()
        return _hx_local_0

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_0(v):
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        return _hx_local_0

    @staticmethod
    def defer(f):
        haxe_Timer.delay(f,0)
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_


class tink_core_LinkObject:
    _hx_class_name = "tink.core.LinkObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["cancel"]
tink_core_LinkObject._hx_class = tink_core_LinkObject


class tink_core_CallbackLinkRef:
    _hx_class_name = "tink.core.CallbackLinkRef"
    _hx_is_interface = "False"
    __slots__ = ("link",)
    _hx_fields = ["link"]
    _hx_methods = ["set_link", "cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self):
        self.link = None

    def set_link(self,param):
        this1 = self.link
        if (this1 is not None):
            this1.cancel()
        def _hx_local_1():
            def _hx_local_0():
                self.link = param
                return self.link
            return _hx_local_0()
        return _hx_local_1()

    def cancel(self):
        this1 = self.link
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.link = None
tink_core_CallbackLinkRef._hx_class = tink_core_CallbackLinkRef


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "noop", "toFunction", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        return tink_core_SimpleLink(link)

    @staticmethod
    def cancel(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def dissolve(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def toFunction(this1):
        if (this1 is None):
            return tink_core__Callback_CallbackLink_Impl_.noop
        else:
            return this1.cancel

    @staticmethod
    def toCallback(this1):
        if (this1 is None):
            def _hx_local_1():
                def _hx_local_0(_):
                    tink_core__Callback_CallbackLink_Impl_.noop()
                return _hx_local_0
            return _hx_local_1()
        else:
            f = this1.cancel
            def _hx_local_2(_):
                f()
            return _hx_local_2

    @staticmethod
    def fromFunction(f):
        return tink_core_SimpleLink(f)

    @staticmethod
    def join(this1,b):
        return tink_core__Callback_LinkPair(this1,b)

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_2():
            def _hx_local_1():
                nonlocal callbacks
                if (callbacks is not None):
                    _g = 0
                    while (_g < len(callbacks)):
                        cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                        _g = (_g + 1)
                        if (cb is not None):
                            cb.cancel()
                else:
                    callbacks = None
            return tink_core_SimpleLink(_hx_local_1)
        return _hx_local_2()
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_


class tink_core_SimpleLink:
    _hx_class_name = "tink.core.SimpleLink"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,f):
        self.f = f

    def cancel(self):
        if (self.f is not None):
            self.f()
            self.f = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_core_SimpleLink._hx_class = tink_core_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,a,b):
        self.dissolved = False
        self.a = a
        self.b = b

    def cancel(self):
        if (not self.dissolved):
            self.dissolved = True
            this1 = self.a
            if (this1 is not None):
                this1.cancel()
            this1 = self.b
            if (this1 is not None):
                this1.cancel()
            self.a = None
            self.b = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
        _hx_o.dissolved = None
tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    _hx_is_interface = "False"
    __slots__ = ("cb", "list")
    _hx_fields = ["cb", "list"]
    _hx_methods = ["invoke", "clear", "cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,cb,_hx_list):
        if (cb is None):
            raise haxe_Exception.thrown("callback expected but null received")
        self.cb = cb
        self.list = _hx_list

    def invoke(self,data):
        if (self.list is not None):
            self.cb(data)

    def clear(self):
        self.cb = None
        self.list = None

    def cancel(self):
        if (self.list is not None):
            _hx_list = self.list
            self.cb = None
            self.list = None
            def _hx_local_1():
                _hx_list.used = (_hx_list.used - 1)
                return _hx_list.used
            tmp = _hx_local_1()
            if (tmp <= ((len(_hx_list.cells) >> 1))):
                _hx_list.compact()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cb = None
        _hx_o.list = None
tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell


class tink_core_Disposable:
    _hx_class_name = "tink.core.Disposable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get_disposed", "ondispose"]
tink_core_Disposable._hx_class = tink_core_Disposable


class tink_core_OwnedDisposable:
    _hx_class_name = "tink.core.OwnedDisposable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["dispose"]
    _hx_interfaces = [tink_core_Disposable]
tink_core_OwnedDisposable._hx_class = tink_core_OwnedDisposable


class tink_core_SimpleDisposable:
    _hx_class_name = "tink.core.SimpleDisposable"
    _hx_is_interface = "False"
    __slots__ = ("f", "disposeHandlers")
    _hx_fields = ["f", "disposeHandlers"]
    _hx_methods = ["get_disposed", "ondispose", "dispose"]
    _hx_statics = ["noop"]
    _hx_interfaces = [tink_core_OwnedDisposable]

    def __init__(self,dispose):
        self.disposeHandlers = []
        self.f = dispose

    def get_disposed(self):
        return (self.disposeHandlers is None)

    def ondispose(self,d):
        _g = self.disposeHandlers
        if (_g is None):
            d()
        else:
            v = _g
            v.append(d)

    def dispose(self):
        _g = self.disposeHandlers
        if (_g is not None):
            v = _g
            self.disposeHandlers = None
            f = self.f
            self.f = tink_core_SimpleDisposable.noop
            f()
            _g = 0
            while (_g < len(v)):
                h = (v[_g] if _g >= 0 and _g < len(v) else None)
                _g = (_g + 1)
                h()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.disposeHandlers = None
tink_core_SimpleDisposable._hx_class = tink_core_SimpleDisposable


class tink_core_CallbackList(tink_core_SimpleDisposable):
    _hx_class_name = "tink.core.CallbackList"
    _hx_is_interface = "False"
    __slots__ = ("destructive", "cells", "used", "queue", "busy", "ondrain", "onfill")
    _hx_fields = ["destructive", "cells", "used", "queue", "busy", "ondrain", "onfill"]
    _hx_methods = ["get_length", "release", "destroy", "drain", "add", "invoke", "compact", "resize", "clear"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_SimpleDisposable


    def __init__(self,destructive = None):
        if (destructive is None):
            destructive = False
        self.cells = None
        self.destructive = None
        def _hx_local_0():
            pass
        self.onfill = _hx_local_0
        def _hx_local_1():
            pass
        self.ondrain = _hx_local_1
        self.busy = False
        self.queue = []
        self.used = 0
        _gthis = self
        def _hx_local_2():
            if (not _gthis.busy):
                _gthis.destroy()
        super().__init__(_hx_local_2)
        self.destructive = destructive
        self.cells = []

    def get_length(self):
        return self.used

    def release(self):
        self.used = (self.used - 1)
        tmp = self.used
        if (tmp <= ((len(self.cells) >> 1))):
            self.compact()

    def destroy(self):
        _g = 0
        _g1 = self.cells
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.cb = None
            c.list = None
        self.queue = None
        self.cells = None
        if (self.used > 0):
            self.used = 0
            fn = self.ondrain
            if (tink_core__Callback_Callback_Impl_.depth < 100):
                _hx_local_1 = tink_core__Callback_Callback_Impl_
                _hx_local_2 = _hx_local_1.depth
                _hx_local_1.depth = (_hx_local_2 + 1)
                _hx_local_2
                fn()
                _hx_local_3 = tink_core__Callback_Callback_Impl_
                _hx_local_4 = _hx_local_3.depth
                _hx_local_3.depth = (_hx_local_4 - 1)
                _hx_local_4
            else:
                tink_core__Callback_Callback_Impl_.defer(fn)

    def drain(self):
        fn = self.ondrain
        if (tink_core__Callback_Callback_Impl_.depth < 100):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            fn()
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            tink_core__Callback_Callback_Impl_.defer(fn)

    def add(self,cb):
        if (self.disposeHandlers is None):
            return None
        node = tink_core__Callback_ListCell(cb,self)
        _this = self.cells
        _this.append(node)
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.used
            _hx_local_0.used = (_hx_local_1 + 1)
            return _hx_local_1
        tmp = (_hx_local_2() == 0)
        if tmp:
            fn = self.onfill
            if (tink_core__Callback_Callback_Impl_.depth < 100):
                _hx_local_3 = tink_core__Callback_Callback_Impl_
                _hx_local_4 = _hx_local_3.depth
                _hx_local_3.depth = (_hx_local_4 + 1)
                _hx_local_4
                fn()
                _hx_local_5 = tink_core__Callback_Callback_Impl_
                _hx_local_6 = _hx_local_5.depth
                _hx_local_5.depth = (_hx_local_6 - 1)
                _hx_local_6
            else:
                tink_core__Callback_Callback_Impl_.defer(fn)
        return node

    def invoke(self,data):
        _gthis = self
        if (tink_core__Callback_Callback_Impl_.depth < 100):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            if (_gthis.disposeHandlers is not None):
                if _gthis.busy:
                    if (_gthis.destructive != True):
                        _this = _gthis.queue
                        tmp = _this.append
                        _g = _gthis
                        data1 = data
                        def _hx_local_2():
                            _g.invoke(data1)
                        tmp(_hx_local_2)
                else:
                    _gthis.busy = True
                    if _gthis.destructive:
                        _gthis.dispose()
                    length = len(_gthis.cells)
                    _g1 = 0
                    _g2 = length
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        _this = (_gthis.cells[i] if i >= 0 and i < len(_gthis.cells) else None)
                        if (_this.list is not None):
                            _this.cb(data)
                    _gthis.busy = False
                    if (_gthis.disposeHandlers is None):
                        _gthis.destroy()
                    else:
                        if (_gthis.used < len(_gthis.cells)):
                            _gthis.compact()
                        if (len(_gthis.queue) > 0):
                            _this = _gthis.queue
                            ((None if ((len(_this) == 0)) else _this.pop(0)))()
            _hx_local_3 = tink_core__Callback_Callback_Impl_
            _hx_local_4 = _hx_local_3.depth
            _hx_local_3.depth = (_hx_local_4 - 1)
            _hx_local_4
        else:
            def _hx_local_6():
                if (_gthis.disposeHandlers is not None):
                    if _gthis.busy:
                        if (_gthis.destructive != True):
                            _this = _gthis.queue
                            tmp = _this.append
                            _g = _gthis
                            data1 = data
                            def _hx_local_5():
                                _g.invoke(data1)
                            tmp(_hx_local_5)
                    else:
                        _gthis.busy = True
                        if _gthis.destructive:
                            _gthis.dispose()
                        length = len(_gthis.cells)
                        _g1 = 0
                        _g2 = length
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            _this = (_gthis.cells[i] if i >= 0 and i < len(_gthis.cells) else None)
                            if (_this.list is not None):
                                _this.cb(data)
                        _gthis.busy = False
                        if (_gthis.disposeHandlers is None):
                            _gthis.destroy()
                        else:
                            if (_gthis.used < len(_gthis.cells)):
                                _gthis.compact()
                            if (len(_gthis.queue) > 0):
                                _this = _gthis.queue
                                ((None if ((len(_this) == 0)) else _this.pop(0)))()
            tink_core__Callback_Callback_Impl_.defer(_hx_local_6)

    def compact(self):
        if self.busy:
            return
        elif (self.used == 0):
            self.resize(0)
            fn = self.ondrain
            if (tink_core__Callback_Callback_Impl_.depth < 100):
                _hx_local_0 = tink_core__Callback_Callback_Impl_
                _hx_local_1 = _hx_local_0.depth
                _hx_local_0.depth = (_hx_local_1 + 1)
                _hx_local_1
                fn()
                _hx_local_2 = tink_core__Callback_Callback_Impl_
                _hx_local_3 = _hx_local_2.depth
                _hx_local_2.depth = (_hx_local_3 - 1)
                _hx_local_3
            else:
                tink_core__Callback_Callback_Impl_.defer(fn)
        else:
            compacted = 0
            _g = 0
            _g1 = len(self.cells)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _g2 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                _g3 = _g2.list
                if (_g2.cb is not None):
                    v = _g2
                    if (compacted != i):
                        python_internal_ArrayImpl._set(self.cells, compacted, v)
                    compacted = (compacted + 1)
                    tmp = compacted
                    if (tmp == self.used):
                        break
            self.resize(self.used)

    def resize(self,length):
        _this = self.cells
        l = len(_this)
        if (l < length):
            idx = (length - 1)
            v = None
            l1 = len(_this)
            while (l1 < idx):
                _this.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                _this.append(v)
            else:
                _this[idx] = v
        elif (l > length):
            pos = length
            _hx_len = (l - length)
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]

    def clear(self):
        if self.busy:
            _this = self.queue
            _this.append(self.clear)
        _g = 0
        _g1 = self.cells
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cell.cb = None
            cell.list = None
        self.resize(0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.destructive = None
        _hx_o.cells = None
        _hx_o.used = None
        _hx_o.queue = None
        _hx_o.busy = None
        _hx_o.ondrain = None
        _hx_o.onfill = None
tink_core_CallbackList._hx_class = tink_core_CallbackList


class tink_core_AlreadyDisposed:
    _hx_class_name = "tink.core.AlreadyDisposed"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["get_disposed", "ondispose", "dispose"]
    _hx_statics = ["INST"]
    _hx_interfaces = [tink_core_OwnedDisposable]

    def __init__(self):
        pass

    def get_disposed(self):
        return True

    def ondispose(self,d):
        d()

    def dispose(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_core_AlreadyDisposed._hx_class = tink_core_AlreadyDisposed


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    _hx_is_interface = "False"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "toPromise", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = None,message = None,pos = None):
        if (code is None):
            code = 500
        self.data = None
        self.isTinkError = True
        self.code = code
        self.message = message
        self.pos = pos
        self.exceptionStack = []
        self.callStack = []

    def printPos(self):
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        return ret

    def toPromise(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(self)))

    def throwSelf(self):
        any = self
        raise haxe_Exception.thrown(any)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        ret = tink_core_TypedError(code,message,pos)
        ret.data = data
        return ret

    @staticmethod
    def asError(v):
        return Std.downcast(v,tink_core_TypedError)

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        try:
            return tink_core_Outcome.Success(f())
        except BaseException as _g:
            None
            ex = haxe_Exception.caught(_g).unwrap()
            e = tink_core_TypedError.asError(ex)
            tmp = None
            if (e is None):
                tmp = (tink_core_TypedError.withData(None,"Unexpected Error",ex,pos) if ((report is None)) else report(ex))
            else:
                e1 = e
                tmp = e1
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        def _hx_local_0(e):
            return tink_core_TypedError.withData(code,message,e,pos)
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        raise haxe_Exception.thrown(any)

    @staticmethod
    def tryFinally(f,cleanup):
        try:
            ret = f()
            cleanup()
            return ret
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            cleanup()
            raise haxe_Exception.thrown(e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
        _hx_o.code = None
        _hx_o.data = None
        _hx_o.pos = None
        _hx_o.callStack = None
        _hx_o.exceptionStack = None
        _hx_o.isTinkError = None
tink_core_TypedError._hx_class = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_


class tink_core__Future_FutureObject:
    _hx_class_name = "tink.core._Future.FutureObject"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["getStatus", "handle", "eager"]

    def __init__(self):
        pass

    def getStatus(self):
        return tink_core_FutureStatus.NeverEver

    def handle(self,callback):
        return None

    def eager(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_core__Future_FutureObject._hx_class = tink_core__Future_FutureObject


class tink_core__Lazy_Computable:
    _hx_class_name = "tink.core._Lazy.Computable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["isComputed", "compute", "underlying"]
tink_core__Lazy_Computable._hx_class = tink_core__Lazy_Computable


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get"]
    _hx_interfaces = [tink_core__Lazy_Computable]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["isComputed", "get", "compute", "underlying"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,value):
        self.value = value

    def isComputed(self):
        return True

    def get(self):
        return self.value

    def compute(self):
        pass

    def underlying(self):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture(tink_core__Future_FutureObject):
    _hx_class_name = "tink.core._Future.SyncFuture"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["getStatus", "handle", "eager"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core__Future_FutureObject


    def __init__(self,value):
        self.value = None
        super().__init__()
        self.value = value

    def getStatus(self):
        return tink_core_FutureStatus.Ready(self.value)

    def handle(self,cb):
        tink_core__Callback_Callback_Impl_.invoke(cb,tink_core__Lazy_Lazy_Impl_.get(self.value))
        return None

    def eager(self):
        if (not self.value.isComputed()):
            tink_core__Lazy_Lazy_Impl_.get(self.value)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NOISE", "NEVER_INST", "NEVER", "never", "get_status", "_new", "handle", "eager", "noise", "first", "map", "flatMap", "swap", "next", "withSideEffect", "gather", "merge", "flatten", "neverToAny", "ofAny", "asPromise", "ofMany", "inParallel", "inSequence", "many", "processMany", "lazy", "sync", "isFuture", "make", "irreversible", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger", "delay"]
    status = None

    @staticmethod
    def never():
        return tink_core__Future_Future_Impl_.NEVER_INST

    @staticmethod
    def get_status(this1):
        return this1.getStatus()

    @staticmethod
    def _new(wakeup):
        return tink_core__Future_SuspendableFuture(wakeup)

    @staticmethod
    def handle(this1,callback):
        return this1.handle(callback)

    @staticmethod
    def eager(this1):
        this1.eager()
        return this1

    @staticmethod
    def noise(this1):
        if (this1.getStatus().index == 4):
            return tink_core__Future_Future_Impl_.never()
        else:
            def _hx_local_1():
                def _hx_local_0(_):
                    return None
                return tink_core__Future_Future_Impl_.map(this1,_hx_local_0)
            return _hx_local_1()

    @staticmethod
    def first(this1,that):
        _g = this1
        _g1 = _g.getStatus()
        tmp = _g1.index
        if (tmp == 3):
            _g2 = _g1.params[0]
            _g1 = that.getStatus()
            tmp = _g1.index
            if (tmp == 3):
                _g2 = _g1.params[0]
                v = _g
                return v
            elif (tmp == 4):
                v = _g
                return v
            else:
                v = _g
                return v
        elif (tmp == 4):
            v = that
            return v
        else:
            _g1 = that.getStatus()
            tmp = _g1.index
            if (tmp == 3):
                _g2 = _g1.params[0]
                v = that
                return v
            elif (tmp == 4):
                v = _g
                return v
            else:
                def _hx_local_1():
                    def _hx_local_0(fire):
                        return tink_core__Callback_LinkPair(this1.handle(fire),that.handle(fire))
                    return tink_core__Future_SuspendableFuture(_hx_local_0)
                return _hx_local_1()

    @staticmethod
    def map(this1,f,gather = None):
        _g = this1.getStatus()
        tmp = _g.index
        if (tmp == 3):
            l = _g.params[0]
            this2 = l
            f1 = f
            def _hx_local_1():
                def _hx_local_0():
                    return f1(this2.get())
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyFunc(_hx_local_0,this2))
            return _hx_local_1()
        elif (tmp == 4):
            return tink_core__Future_Future_Impl_.never()
        else:
            def _hx_local_5():
                def _hx_local_4(fire):
                    def _hx_local_3():
                        def _hx_local_2(v):
                            fire(f(v))
                        return this1.handle(_hx_local_2)
                    return _hx_local_3()
                return tink_core__Future_SuspendableFuture(_hx_local_4)
            return _hx_local_5()

    @staticmethod
    def flatMap(this1,next,gather = None):
        _g = this1.getStatus()
        tmp = _g.index
        if (tmp == 3):
            l = _g.params[0]
            def _hx_local_3():
                def _hx_local_2(fire):
                    def _hx_local_1():
                        def _hx_local_0(v):
                            fire(v)
                        return next(tink_core__Lazy_Lazy_Impl_.get(l)).handle(_hx_local_0)
                    return _hx_local_1()
                return tink_core__Future_SuspendableFuture(_hx_local_2)
            return _hx_local_3()
        elif (tmp == 4):
            return tink_core__Future_Future_Impl_.never()
        else:
            def _hx_local_6():
                def _hx_local_5(_hx_yield):
                    inner = tink_core_CallbackLinkRef()
                    def _hx_local_4(v):
                        param = next(v).handle(_hx_yield)
                        this1 = inner.link
                        if (this1 is not None):
                            this1.cancel()
                        inner.link = param
                    outer = this1.handle(_hx_local_4)
                    return tink_core__Callback_LinkPair(outer,inner)
                return tink_core__Future_SuspendableFuture(_hx_local_5)
            return _hx_local_6()

    @staticmethod
    def swap(this1,v):
        def _hx_local_1():
            def _hx_local_0(_):
                return v
            return tink_core__Future_Future_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def next(this1,n):
        return tink_core__Future_Future_Impl_.flatMap(this1,n)

    @staticmethod
    def withSideEffect(this1,c):
        def _hx_local_1():
            def _hx_local_0(v):
                tink_core__Callback_Callback_Impl_.invoke(c,v)
                return v
            return tink_core__Future_Future_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        return this1

    @staticmethod
    def merge(this1,that,combine):
        _g = this1.getStatus()
        _g1 = that.getStatus()
        if (_g.index == 4):
            return tink_core__Future_Future_Impl_.never()
        elif (_g1.index == 4):
            return tink_core__Future_Future_Impl_.never()
        else:
            def _hx_local_2():
                def _hx_local_1(_hx_yield):
                    def _hx_local_0(v = None):
                        _g = this1.getStatus()
                        _g1 = that.getStatus()
                        if (_g.index == 3):
                            if (_g1.index == 3):
                                b = _g1.params[0]
                                a = _g.params[0]
                                _hx_yield(combine(tink_core__Lazy_Lazy_Impl_.get(a),tink_core__Lazy_Lazy_Impl_.get(b)))
                    check = _hx_local_0
                    return tink_core__Callback_LinkPair(this1.handle(check),that.handle(check))
                return tink_core__Future_SuspendableFuture(_hx_local_1)
            return _hx_local_2()

    @staticmethod
    def flatten(f):
        def _hx_local_1():
            def _hx_local_0(v):
                return v
            return tink_core__Future_Future_Impl_.flatMap(f,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def neverToAny(l):
        return l

    @staticmethod
    def ofAny(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def asPromise(s):
        return s

    @staticmethod
    def ofMany(futures,gather = None):
        return tink_core__Future_Future_Impl_.inSequence(futures)

    @staticmethod
    def inParallel(futures,concurrency = None):
        return tink_core__Future_Future_Impl_.many(futures,concurrency)

    @staticmethod
    def inSequence(futures):
        return tink_core__Future_Future_Impl_.many(futures,1)

    @staticmethod
    def many(a,concurrency = None):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.orNull(o)
            return tink_core__Future_Future_Impl_.processMany(a,concurrency,tink_core_Outcome.Success,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def processMany(a,concurrency = None,fn = None,lift = None):
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(lift(tink_core_Outcome.Success([]))))
        else:
            def _hx_local_12():
                def _hx_local_11(_hx_yield):
                    links = list()
                    _g = []
                    _g1 = 0
                    while (_g1 < len(a)):
                        x = (a[_g1] if _g1 >= 0 and _g1 < len(a) else None)
                        _g1 = (_g1 + 1)
                        _g.append(None)
                    ret = _g
                    index = 0
                    pending = 0
                    done = False
                    concurrency1 = None
                    if (concurrency is None):
                        concurrency1 = len(a)
                    else:
                        v = concurrency
                        concurrency1 = (1 if ((v < 1)) else (len(a) if ((v > len(a))) else v))
                    def _hx_local_1():
                        nonlocal done
                        if (index == len(ret)):
                            if (pending == 0):
                                v = lift(tink_core_Outcome.Success(ret))
                                done = True
                                _hx_yield(v)
                                return True
                            else:
                                return False
                        else:
                            return False
                    fireWhenReady = _hx_local_1
                    step = None
                    def _hx_local_10():
                        nonlocal pending
                        nonlocal index
                        if ((not done) and (not fireWhenReady())):
                            while (index < len(ret)):
                                index = (index + 1)
                                index1 = [(index - 1)]
                                p = python_internal_ArrayImpl._get(a, (index1[0] if 0 < len(index1) else None))
                                def _hx_local_5(index):
                                    def _hx_local_3(o):
                                        nonlocal done
                                        _g = fn(o)
                                        check = _g.index
                                        if (check == 0):
                                            v = _g.params[0]
                                            python_internal_ArrayImpl._set(ret, (index[0] if 0 < len(index) else None), v)
                                            fireWhenReady()
                                        elif (check == 1):
                                            e = _g.params[0]
                                            _g = 0
                                            while (_g < len(links)):
                                                l = (links[_g] if _g >= 0 and _g < len(links) else None)
                                                _g = (_g + 1)
                                                if (l is not None):
                                                    l.cancel()
                                            v = lift(tink_core_Outcome.Failure(e))
                                            done = True
                                            _hx_yield(v)
                                        else:
                                            pass
                                    return _hx_local_3
                                check = [_hx_local_5(index1)]
                                _g = p.getStatus()
                                if (_g.index == 3):
                                    _hx_tmp = None
                                    _hx_tmp = tink_core__Lazy_Lazy_Impl_.get(_g.params[0])
                                    v = _hx_tmp
                                    (check[0] if 0 < len(check) else None)(v)
                                    if (not done):
                                        continue
                                else:
                                    pending = (pending + 1)
                                    def _hx_local_9(check):
                                        def _hx_local_7(o):
                                            nonlocal pending
                                            pending = (pending - 1)
                                            (check[0] if 0 < len(check) else None)(o)
                                            if (not done):
                                                step()
                                        return _hx_local_7
                                    x = p.handle(_hx_local_9(check))
                                    links.append(x)
                                break
                    step = _hx_local_10
                    _g = 0
                    _g1 = concurrency1
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        step()
                    return tink_core__Callback_CallbackLink_Impl_.fromMany(links)
                return tink_core__Future_SuspendableFuture(_hx_local_11)
            return _hx_local_12()

    @staticmethod
    def lazy(l):
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def isFuture(maybeFuture):
        return Std.isOfType(maybeFuture,tink_core__Future_FutureObject)

    @staticmethod
    def make(init,lazy = None):
        if (lazy is None):
            lazy = False
        ret = tink_core__Future_Future_Impl_.irreversible(init)
        if lazy:
            return ret
        else:
            ret.eager()
            return ret

    @staticmethod
    def irreversible(init):
        def _hx_local_1():
            def _hx_local_0(_hx_yield):
                init(_hx_yield)
                return None
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _hx_or(a,b):
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        return tink_core__Future_Future_Impl_.first(tink_core__Future_Future_Impl_.map(a,haxe_ds_Either.Left),tink_core__Future_Future_Impl_.map(b,haxe_ds_Either.Right))

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a,b):
                return tink_core_MPair(a,b)
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return _hx_map(d)
                elif (tmp == 1):
                    f = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f)))
                else:
                    pass
            return tink_core__Future_Future_Impl_.flatMap(f,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return tink_core__Future_Future_Impl_.map(_hx_map(d),tink_core_Outcome.Success)
                elif (tmp == 1):
                    f = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f)))
                else:
                    pass
            return tink_core__Future_Future_Impl_.flatMap(f,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
            return tink_core__Future_Future_Impl_.map(f,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.map(o,_hx_map)
            return tink_core__Future_Future_Impl_.map(f,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _flatMap(f,_hx_map):
        return tink_core__Future_Future_Impl_.flatMap(f,_hx_map)

    @staticmethod
    def _map(f,_hx_map):
        return tink_core__Future_Future_Impl_.map(f,_hx_map)

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()

    @staticmethod
    def delay(ms,value):
        def _hx_local_1(cb):
            def _hx_local_0():
                cb(tink_core__Lazy_Lazy_Impl_.get(value))
            haxe_Timer.delay(_hx_local_0,ms)
        this1 = tink_core__Future_Future_Impl_.irreversible(_hx_local_1)
        this1.eager()
        return this1
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_

class tink_core_FutureStatus(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.FutureStatus"
    _hx_constructs = ["Suspended", "Awaited", "EagerlyAwaited", "Ready", "NeverEver"]

    @staticmethod
    def Ready(result):
        return tink_core_FutureStatus("Ready", 3, (result,))
tink_core_FutureStatus.Suspended = tink_core_FutureStatus("Suspended", 0, ())
tink_core_FutureStatus.Awaited = tink_core_FutureStatus("Awaited", 1, ())
tink_core_FutureStatus.EagerlyAwaited = tink_core_FutureStatus("EagerlyAwaited", 2, ())
tink_core_FutureStatus.NeverEver = tink_core_FutureStatus("NeverEver", 4, ())
tink_core_FutureStatus._hx_class = tink_core_FutureStatus


class tink_core_FutureTrigger(tink_core__Future_FutureObject):
    _hx_class_name = "tink.core.FutureTrigger"
    _hx_is_interface = "False"
    __slots__ = ("status", "list")
    _hx_fields = ["status", "list"]
    _hx_methods = ["getStatus", "handle", "asFuture", "trigger"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core__Future_FutureObject


    def __init__(self):
        self.list = None
        self.status = tink_core_FutureStatus.Awaited
        super().__init__()
        self.list = tink_core_CallbackList(True)

    def getStatus(self):
        return self.status

    def handle(self,callback):
        _g = self.status
        if (_g.index == 3):
            result = _g.params[0]
            tink_core__Callback_Callback_Impl_.invoke(callback,tink_core__Lazy_Lazy_Impl_.get(result))
            return None
        else:
            v = _g
            _this = self.list
            if (_this.disposeHandlers is None):
                return None
            else:
                node = tink_core__Callback_ListCell(callback,_this)
                _this1 = _this.cells
                _this1.append(node)
                def _hx_local_1():
                    _hx_local_0 = _this.used
                    _this.used = (_this.used + 1)
                    return _hx_local_0
                tmp = (_hx_local_1() == 0)
                if tmp:
                    fn = _this.onfill
                    if (tink_core__Callback_Callback_Impl_.depth < 100):
                        _hx_local_2 = tink_core__Callback_Callback_Impl_
                        _hx_local_3 = _hx_local_2.depth
                        _hx_local_2.depth = (_hx_local_3 + 1)
                        _hx_local_3
                        fn()
                        _hx_local_4 = tink_core__Callback_Callback_Impl_
                        _hx_local_5 = _hx_local_4.depth
                        _hx_local_4.depth = (_hx_local_5 - 1)
                        _hx_local_5
                    else:
                        tink_core__Callback_Callback_Impl_.defer(fn)
                return node

    def asFuture(self):
        return self

    def trigger(self,result):
        _g = self.status
        if (_g.index == 3):
            _g1 = _g.params[0]
            return False
        else:
            self.status = tink_core_FutureStatus.Ready(tink_core__Lazy_LazyConst(result))
            self.list.invoke(result)
            return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.status = None
        _hx_o.list = None
tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger


class tink_core__Future_SuspendableFuture(tink_core__Future_FutureObject):
    _hx_class_name = "tink.core._Future.SuspendableFuture"
    _hx_is_interface = "False"
    __slots__ = ("callbacks", "status", "link", "wakeup")
    _hx_fields = ["callbacks", "status", "link", "wakeup"]
    _hx_methods = ["getStatus", "trigger", "handle", "arm", "eager"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core__Future_FutureObject


    def __init__(self,wakeup):
        self.wakeup = None
        self.link = None
        self.callbacks = None
        self.status = tink_core_FutureStatus.Suspended
        _gthis = self
        super().__init__()
        self.wakeup = wakeup
        self.callbacks = tink_core_CallbackList(True)
        def _hx_local_0():
            if (_gthis.status == tink_core_FutureStatus.Awaited):
                _gthis.status = tink_core_FutureStatus.Suspended
                this1 = _gthis.link
                if (this1 is not None):
                    this1.cancel()
                _gthis.link = None
        self.callbacks.ondrain = _hx_local_0
        def _hx_local_1():
            if (_gthis.status == tink_core_FutureStatus.Suspended):
                _gthis.status = tink_core_FutureStatus.Awaited
                _gthis.arm()
        self.callbacks.onfill = _hx_local_1

    def getStatus(self):
        return self.status

    def trigger(self,value):
        _g = self.status
        if (_g.index == 3):
            _g1 = _g.params[0]
        else:
            self.status = tink_core_FutureStatus.Ready(tink_core__Lazy_LazyConst(value))
            link = self.link
            self.link = None
            self.wakeup = None
            self.callbacks.invoke(value)
            if (link is not None):
                link.cancel()

    def handle(self,callback):
        _g = self.status
        if (_g.index == 3):
            result = _g.params[0]
            tink_core__Callback_Callback_Impl_.invoke(callback,tink_core__Lazy_Lazy_Impl_.get(result))
            return None
        else:
            _this = self.callbacks
            if (_this.disposeHandlers is None):
                return None
            else:
                node = tink_core__Callback_ListCell(callback,_this)
                _this1 = _this.cells
                _this1.append(node)
                def _hx_local_1():
                    _hx_local_0 = _this.used
                    _this.used = (_this.used + 1)
                    return _hx_local_0
                tmp = (_hx_local_1() == 0)
                if tmp:
                    fn = _this.onfill
                    if (tink_core__Callback_Callback_Impl_.depth < 100):
                        _hx_local_2 = tink_core__Callback_Callback_Impl_
                        _hx_local_3 = _hx_local_2.depth
                        _hx_local_2.depth = (_hx_local_3 + 1)
                        _hx_local_3
                        fn()
                        _hx_local_4 = tink_core__Callback_Callback_Impl_
                        _hx_local_5 = _hx_local_4.depth
                        _hx_local_4.depth = (_hx_local_5 - 1)
                        _hx_local_5
                    else:
                        tink_core__Callback_Callback_Impl_.defer(fn)
                return node

    def arm(self):
        _gthis = self
        def _hx_local_0(x):
            _gthis.trigger(x)
        self.link = self.wakeup(_hx_local_0)

    def eager(self):
        tmp = self.status.index
        if (tmp == 0):
            self.status = tink_core_FutureStatus.EagerlyAwaited
            self.arm()
        elif (tmp == 1):
            self.status = tink_core_FutureStatus.EagerlyAwaited
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.callbacks = None
        _hx_o.status = None
        _hx_o.link = None
        _hx_o.wakeup = None
tink_core__Future_SuspendableFuture._hx_class = tink_core__Future_SuspendableFuture


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NOISE", "NULL", "get_computed", "get", "fromNoise", "ofFunc", "map", "flatMap", "ofConst"]
    computed = None

    @staticmethod
    def get_computed(this1):
        return this1.isComputed()

    @staticmethod
    def get(this1):
        this1.compute()
        return this1.get()

    @staticmethod
    def fromNoise(l):
        return l

    @staticmethod
    def ofFunc(f):
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        def _hx_local_1():
            def _hx_local_0():
                return f(this1.get())
            return tink_core__Lazy_LazyFunc(_hx_local_0,this1)
        return _hx_local_1()

    @staticmethod
    def flatMap(this1,f):
        def _hx_local_1():
            def _hx_local_0():
                return tink_core__Lazy_Lazy_Impl_.get(f(this1.get()))
            return tink_core__Lazy_LazyFunc(_hx_local_0,this1)
        return _hx_local_1()

    @staticmethod
    def ofConst(c):
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    _hx_is_interface = "False"
    __slots__ = ("f", "_hx_from", "result")
    _hx_fields = ["f", "from", "result"]
    _hx_methods = ["underlying", "isComputed", "get", "compute"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,f,_hx_from = None):
        self.result = None
        self.f = f
        self._hx_from = _hx_from

    def underlying(self):
        return self._hx_from

    def isComputed(self):
        return (self.f is None)

    def get(self):
        return self.result

    def compute(self):
        _g = self.f
        if (_g is not None):
            v = _g
            self.f = None
            _g = self._hx_from
            if (_g is not None):
                cur = _g
                self._hx_from = None
                stack = []
                while ((cur is not None) and (not cur.isComputed())):
                    stack.append(cur)
                    cur = cur.underlying()
                stack.reverse()
                _g = 0
                while (_g < len(stack)):
                    c = (stack[_g] if _g >= 0 and _g < len(stack) else None)
                    _g = (_g + 1)
                    c.compute()
            self.result = v()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o._hx_from = None
        _hx_o.result = None
tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    _hx_is_interface = "False"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        self.name = name
        self.value = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.value = None
tink_core_NamedWith._hx_class = tink_core_NamedWith


class tink_core__Noise_Noise_Impl_:
    _hx_class_name = "tink.core._Noise.Noise_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Noise", "ofAny"]

    @staticmethod
    def ofAny(t):
        return None
tink_core__Noise_Noise_Impl_._hx_class = tink_core__Noise_Noise_Impl_


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["force", "sure", "toOutcome", "or", "orTry", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            raise haxe_Exception.thrown(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def sure(o,pos = None):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            raise haxe_Exception.thrown(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def toOutcome(o,pos = None):
        tmp = o.index
        if (tmp == 0):
            value = o.params[0]
            return tink_core_Outcome.Success(value)
        elif (tmp == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "tink/core/Option.hx", 'lineNumber': 31, 'className': "tink.core.OptionTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def _hx_or(o,l):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return tink_core__Lazy_Lazy_Impl_.get(l)

    @staticmethod
    def orTry(o,fallback):
        if (o.index == 0):
            v = o.params[0]
            return o
        else:
            return tink_core__Lazy_Lazy_Impl_.get(fallback)

    @staticmethod
    def orNull(o):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        if (o.index == 0):
            if (f(o.params[0]) == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        if (o.index == 0):
            v1 = o.params[0]
            return HxOverrides.eq(v1,v)
        else:
            return False

    @staticmethod
    def map(o,f):
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        if (o.index == 0):
            v = o.params[0]
            return [v]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    _hx_is_interface = "False"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.value = None
        self.alive = True
        if (o.index == 0):
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        return self.alive

    def next(self):
        self.alive = False
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
        _hx_o.alive = None
tink_core_OptionIter._hx_class = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"
    _hx_constructs = ["Success", "Failure"]

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, (data,))

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, (failure,))
tink_core_Outcome._hx_class = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "orNull", "orUse", "or", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "next", "attempt", "satisfies", "flatten"]

    @staticmethod
    def sure(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            failure = outcome.params[0]
            _g = tink_core_TypedError.asError(failure)
            if (_g is None):
                raise haxe_Exception.thrown(failure)
            else:
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (tmp == 1):
            _g = outcome.params[0]
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def orNull(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g = outcome.params[0]
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        return tink_core_OutcomeTools._hx_or(outcome,fallback)

    @staticmethod
    def _hx_or(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g = outcome.params[0]
            return tink_core__Lazy_Lazy_Impl_.get(fallback)
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            _g = outcome.params[0]
            return outcome
        elif (tmp == 1):
            _g = outcome.params[0]
            return tink_core__Lazy_Lazy_Impl_.get(fallback)
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return HxOverrides.eq(data,to)
        elif (tmp == 1):
            _g = outcome.params[0]
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(transform(a))
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        if (outcome.index == 0):
            _g = outcome.params[0]
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(v)
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def next(outcome,f):
        tmp = outcome.index
        if (tmp == 0):
            v = outcome.params[0]
            return f(v)
        elif (tmp == 1):
            e = outcome.params[0]
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
        else:
            pass

    @staticmethod
    def attempt(f,report):
        try:
            return tink_core_Outcome.Success(f())
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def satisfies(o,f):
        if (o.index == 0):
            d = o.params[0]
            return f(d)
        else:
            return False

    @staticmethod
    def flatten(o):
        tmp = o.index
        if (tmp == 0):
            _g = o.params[0]
            tmp = _g.index
            if (tmp == 0):
                d = _g.params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp == 1):
                f = _g.params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (tmp == 1):
            f = o.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        return _hx_AnonObject({'f': f})

    @staticmethod
    def apply(this1,o):
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return f(d)
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    _g = f(d)
                    tmp = _g.index
                    if (tmp == 0):
                        d = _g.params[0]
                        return tink_core_Outcome.Success(d)
                    elif (tmp == 1):
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f1))
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        return tink_core_MPair(a,b)

    @staticmethod
    def get_a(this1):
        return this1.a

    @staticmethod
    def get_b(this1):
        return this1.b

    @staticmethod
    def toBool(this1):
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        return (this1 is None)

    @staticmethod
    def nil():
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        self.a = a
        self.b = b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
tink_core_MPair._hx_class = tink_core_MPair


class tink_core__Progress_ProgressValue_Impl_:
    _hx_class_name = "tink.core._Progress.ProgressValue_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ZERO", "_new", "normalize", "get_value", "get_total"]
    value = None
    total = None

    @staticmethod
    def _new(value,total):
        return tink_core_MPair(value,total)

    @staticmethod
    def normalize(this1):
        o = this1.b
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some((this1.a / v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def get_value(this1):
        return this1.a

    @staticmethod
    def get_total(this1):
        return this1.b
tink_core__Progress_ProgressValue_Impl_._hx_class = tink_core__Progress_ProgressValue_Impl_


class tink_core__Progress_Progress_Impl_:
    _hx_class_name = "tink.core._Progress.Progress_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["INIT", "listen", "handle", "trigger", "make", "map", "asFuture", "promise", "flatten", "future", "next"]

    @staticmethod
    def listen(this1,cb):
        return this1.progressed.listen(cb)

    @staticmethod
    def handle(this1,cb):
        return this1.result.handle(cb)

    @staticmethod
    def trigger():
        return tink_core_ProgressTrigger()

    @staticmethod
    def make(f):
        def _hx_local_4():
            def _hx_local_3(fire):
                def _hx_local_2():
                    def _hx_local_0(value,total):
                        fire(tink_core_ProgressStatus.InProgress(tink_core_MPair(value,total)))
                    def _hx_local_1(result):
                        fire(tink_core_ProgressStatus.Finished(result))
                    return f(_hx_local_0,_hx_local_1)
                return _hx_local_2()
            return tink_core__Progress_SuspendableProgress(_hx_local_3)
        return _hx_local_4()

    @staticmethod
    def map(this1,f):
        def _hx_local_2():
            def _hx_local_0(s):
                return tink_core_ProgressStatusTools.map(s,f)
            def _hx_local_1():
                return tink_core_ProgressStatusTools.map(this1.getStatus(),f)
            return tink_core__Progress_ProgressObject(tink_core__Signal_Signal_Impl_.map(this1.changed,_hx_local_0),_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def asFuture(this1):
        return this1.result

    @staticmethod
    def promise(v):
        def _hx_local_4():
            def _hx_local_3(fire):
                inner = tink_core_CallbackLinkRef()
                def _hx_local_2():
                    def _hx_local_1(o):
                        this1 = o.index
                        if (this1 == 0):
                            p = o.params[0]
                            def _hx_local_0(s):
                                fire(tink_core_ProgressStatusTools.map(s,tink_core_Outcome.Success))
                            param = p.changed.listen(_hx_local_0)
                            this1 = inner.link
                            if (this1 is not None):
                                this1.cancel()
                            inner.link = param
                        elif (this1 == 1):
                            e = o.params[0]
                            fire(tink_core_ProgressStatus.Finished(tink_core_Outcome.Failure(e)))
                        else:
                            pass
                    return tink_core__Callback_LinkPair(v.handle(_hx_local_1),inner)
                return _hx_local_2()
            return tink_core__Progress_SuspendableProgress(_hx_local_3)
        return _hx_local_4()

    @staticmethod
    def flatten(v):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    _g = o.params[0]
                    tmp = _g.index
                    if (tmp == 0):
                        v = _g.params[0]
                        return tink_core_Outcome.Success(v)
                    elif (tmp == 1):
                        e = _g.params[0]
                        return tink_core_Outcome.Failure(e)
                    else:
                        pass
                elif (tmp == 1):
                    e = o.params[0]
                    return tink_core_Outcome.Failure(e)
                else:
                    pass
            return tink_core__Progress_Progress_Impl_.map(tink_core__Progress_Progress_Impl_.promise(v),_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def future(v):
        def _hx_local_3():
            def _hx_local_2(fire):
                inner = tink_core_CallbackLinkRef()
                def _hx_local_1():
                    def _hx_local_0(p):
                        param = p.changed.listen(fire)
                        this1 = inner.link
                        if (this1 is not None):
                            this1.cancel()
                        inner.link = param
                    return tink_core__Callback_LinkPair(v.handle(_hx_local_0),inner)
                return _hx_local_1()
            return tink_core__Progress_SuspendableProgress(_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def next(this1,f):
        return tink_core__Future_Future_Impl_.flatMap(this1.result,f)
tink_core__Progress_Progress_Impl_._hx_class = tink_core__Progress_Progress_Impl_


class tink_core__Progress_ProgressObject:
    _hx_class_name = "tink.core._Progress.ProgressObject"
    _hx_is_interface = "False"
    __slots__ = ("getStatus", "changed", "progressed", "result")
    _hx_fields = ["getStatus", "changed", "progressed", "result"]
    _hx_methods = ["get_status"]

    def __init__(self,changed,getStatus):
        self.result = None
        self.progressed = None
        self.getStatus = None
        self.changed = changed
        def _hx_local_2(fire):
            def _hx_local_1():
                def _hx_local_0(s):
                    if (s.index == 0):
                        v = s.params[0]
                        fire(v)
                return changed.listen(_hx_local_0)
            return _hx_local_1()
        self.progressed = tink_core__Signal_Suspendable(_hx_local_2,None)
        self.getStatus = getStatus
        def _hx_local_5(fire):
            _g = getStatus()
            if (_g.index == 1):
                v = _g.params[0]
                fire(v)
                return None
            else:
                def _hx_local_4():
                    def _hx_local_3(s):
                        if (s.index == 1):
                            v = s.params[0]
                            fire(v)
                    return changed.listen(_hx_local_3)
                return _hx_local_4()
        self.result = tink_core__Future_SuspendableFuture(_hx_local_5)

    def get_status(self):
        return self.getStatus()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.getStatus = None
        _hx_o.changed = None
        _hx_o.progressed = None
        _hx_o.result = None
tink_core__Progress_ProgressObject._hx_class = tink_core__Progress_ProgressObject


class tink_core__Progress_SuspendableProgress(tink_core__Progress_ProgressObject):
    _hx_class_name = "tink.core._Progress.SuspendableProgress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["noop"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core__Progress_ProgressObject


    def __init__(self,wakeup,status = None):
        if (status is None):
            status = tink_core_ProgressStatus.InProgress(tink_core__Progress_ProgressValue_Impl_.ZERO)
        disposable = tink_core_AlreadyDisposed.INST
        changed = None
        changed1 = status.index
        if (changed1 == 0):
            _g = status.params[0]
            def _hx_local_2(fire):
                def _hx_local_1():
                    def _hx_local_0(s):
                        nonlocal status
                        status = s
                        fire(status)
                    return wakeup(_hx_local_0)
                return _hx_local_1()
            def _hx_local_3(d):
                nonlocal disposable
                disposable = d
            changed = tink_core__Signal_Suspendable(_hx_local_2,_hx_local_3)
        elif (changed1 == 1):
            _g = status.params[0]
            changed = tink_core__Signal_Signal_Impl_.dead()
        else:
            pass
        def _hx_local_4():
            return status
        super().__init__(changed,_hx_local_4)

    def noop(self,_,_1):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_core__Progress_SuspendableProgress._hx_class = tink_core__Progress_SuspendableProgress


class tink_core_ProgressTrigger(tink_core__Progress_ProgressObject):
    _hx_class_name = "tink.core.ProgressTrigger"
    _hx_is_interface = "False"
    __slots__ = ("_status", "_changed")
    _hx_fields = ["_status", "_changed"]
    _hx_methods = ["asProgress", "progress", "finish"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core__Progress_ProgressObject


    def __init__(self,status = None):
        self._status = None
        self._changed = None
        _gthis = self
        if (status is None):
            status = tink_core_ProgressStatus.InProgress(tink_core__Progress_ProgressValue_Impl_.ZERO)
            self._status = status
        tmp = None
        if (status is None):
            tmp = False
        elif (status.index == 1):
            _g = status.params[0]
            tmp = True
        else:
            tmp = False
        def _hx_local_2():
            def _hx_local_0():
                self._changed = tink_core__Signal_Signal_Impl_.trigger()
                return self._changed
            return tink_core__Signal_Signal_Impl_.dead() if tmp else _hx_local_0()
        def _hx_local_3():
            return _gthis._status
        super().__init__(_hx_local_2(),_hx_local_3)

    def asProgress(self):
        return self

    def progress(self,v,total):
        _g = self._status
        tmp = None
        if (_g.index == 1):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        if (not tmp):
            _this = self._changed
            this1 = tink_core_MPair(v,total)
            def _hx_local_0():
                self._status = tink_core_ProgressStatus.InProgress(this1)
                return self._status
            _this.handlers.invoke(_hx_local_0())

    def finish(self,v):
        _g = self._status
        tmp = None
        if (_g.index == 1):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        if (not tmp):
            def _hx_local_0():
                self._status = tink_core_ProgressStatus.Finished(v)
                return self._status
            self._changed.handlers.invoke(_hx_local_0())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._status = None
        _hx_o._changed = None
tink_core_ProgressTrigger._hx_class = tink_core_ProgressTrigger


class tink_core__Progress_UnitInterval_Impl_:
    _hx_class_name = "tink.core._Progress.UnitInterval_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toPercentageString"]

    @staticmethod
    def toPercentageString(this1,dp):
        m = Math.pow(10,dp)
        v = (Math.floor((((this1 * m) * 100) + 0.5)) / m)
        s = Std.string(v)
        startIndex = None
        _g = (s.find(".") if ((startIndex is None)) else HxString.indexOfImpl(s,".",startIndex))
        if (_g == -1):
            return (((("null" if s is None else s) + ".") + HxOverrides.stringOrNull(StringTools.lpad("","0",dp))) + "%")
        else:
            i = _g
            if ((len(s) - i) > dp):
                return (HxOverrides.stringOrNull(HxString.substr(s,0,((dp + i) + 1))) + "%")
            else:
                i = _g
                return (HxOverrides.stringOrNull(StringTools.rpad(s,"0",((i + dp) + 1))) + "%")
tink_core__Progress_UnitInterval_Impl_._hx_class = tink_core__Progress_UnitInterval_Impl_

class tink_core_ProgressStatus(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.ProgressStatus"
    _hx_constructs = ["InProgress", "Finished"]

    @staticmethod
    def InProgress(v):
        return tink_core_ProgressStatus("InProgress", 0, (v,))

    @staticmethod
    def Finished(v):
        return tink_core_ProgressStatus("Finished", 1, (v,))
tink_core_ProgressStatus._hx_class = tink_core_ProgressStatus


class tink_core_ProgressStatusTools:
    _hx_class_name = "tink.core.ProgressStatusTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["map"]

    @staticmethod
    def map(p,f):
        tmp = p.index
        if (tmp == 0):
            v = p.params[0]
            return tink_core_ProgressStatus.InProgress(v)
        elif (tmp == 1):
            v = p.params[0]
            return tink_core_ProgressStatus.Finished(f(v))
        else:
            pass
tink_core_ProgressStatusTools._hx_class = tink_core_ProgressStatusTools


class tink_core_TotalTools:
    _hx_class_name = "tink.core.TotalTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["eq"]

    @staticmethod
    def eq(a,b):
        tmp = a.index
        if (tmp == 0):
            if (b.index == 0):
                t2 = b.params[0]
                t1 = a.params[0]
                return (t1 == t2)
            else:
                return False
        elif (tmp == 1):
            if (b.index == 1):
                return True
            else:
                return False
        else:
            pass
tink_core_TotalTools._hx_class = tink_core_TotalTools


class tink_core_ProgressTools:
    _hx_class_name = "tink.core.ProgressTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asPromise"]

    @staticmethod
    def asPromise(p):
        return p.result
tink_core_ProgressTools._hx_class = tink_core_ProgressTools


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NOISE", "NEVER", "never", "_new", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "withSideEffect", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "irreversible", "and", "iterate", "retry", "ofSpecific", "fromNever", "ofTrigger", "ofHappyTrigger", "ofFuture", "ofOutcome", "ofError", "ofData", "asFuture", "lazy", "inParallel", "many", "inSequence", "cache", "lift", "trigger", "resolve", "reject"]

    @staticmethod
    def never():
        return tink_core__Future_Future_Impl_.never()

    @staticmethod
    def _new(f):
        def _hx_local_4():
            def _hx_local_3(cb):
                def _hx_local_2():
                    def _hx_local_0(v):
                        cb(tink_core_Outcome.Success(v))
                    def _hx_local_1(e):
                        cb(tink_core_Outcome.Failure(e))
                    return f(_hx_local_0,_hx_local_1)
                return _hx_local_2()
            return tink_core__Future_SuspendableFuture(_hx_local_3)
        return _hx_local_4()

    @staticmethod
    def eager(this1):
        this1.eager()
        return this1

    @staticmethod
    def map(this1,f):
        return tink_core__Future_Future_Impl_.map(this1,f)

    @staticmethod
    def flatMap(this1,f):
        return tink_core__Future_Future_Impl_.flatMap(this1,f)

    @staticmethod
    def tryRecover(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                elif (tmp == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            return tink_core__Future_Future_Impl_.flatMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def recover(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
                elif (tmp == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            return tink_core__Future_Future_Impl_.flatMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def mapError(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    _g = o.params[0]
                    return o
                elif (tmp == 1):
                    e = o.params[0]
                    return tink_core_Outcome.Failure(f(e))
                else:
                    pass
            return tink_core__Future_Future_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withSideEffect(this1,c):
        def _hx_local_0(o):
            if (o.index == 0):
                data = o.params[0]
                tink_core__Callback_Callback_Impl_.invoke(c,data)
        c1 = _hx_local_0
        def _hx_local_2():
            def _hx_local_1(v):
                tink_core__Callback_Callback_Impl_.invoke(c1,v)
                return v
            return tink_core__Future_Future_Impl_.map(this1,_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def handle(this1,cb):
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        if (this1.getStatus().index == 4):
            return tink_core__Promise_Promise_Impl_.never()
        else:
            def _hx_local_1():
                def _hx_local_0(v):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
                return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
            return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.isSuccess(o)
            return tink_core__Future_Future_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def next(this1,f,gather = None):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return f(d)
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
                else:
                    pass
            return tink_core__Future_Future_Impl_.flatMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swap(this1,v):
        def _hx_local_1():
            def _hx_local_0(_):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(v)))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        def _hx_local_1():
            def _hx_local_0(_):
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        def _hx_local_2():
            def _hx_local_0(a,b):
                tmp = a.index
                if (tmp == 0):
                    _g = a.params[0]
                    tmp = b.index
                    if (tmp == 0):
                        b1 = b.params[0]
                        a1 = _g
                        return merger(a1,b1)
                    elif (tmp == 1):
                        e = b.params[0]
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
                    else:
                        pass
                elif (tmp == 1):
                    e = a.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
                else:
                    pass
            def _hx_local_1(o):
                return o
            return tink_core__Future_Future_Impl_.flatMap(tink_core__Future_Future_Impl_.merge(this1,other,_hx_local_0),_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def irreversible(f):
        def _hx_local_0(res,rej):
            f(res,rej)
            return None
        f1 = _hx_local_0
        def _hx_local_5():
            def _hx_local_4(cb):
                def _hx_local_3():
                    def _hx_local_1(v):
                        cb(tink_core_Outcome.Success(v))
                    def _hx_local_2(e):
                        cb(tink_core_Outcome.Failure(e))
                    return f1(_hx_local_1,_hx_local_2)
                return _hx_local_3()
            return tink_core__Future_SuspendableFuture(_hx_local_4)
        return _hx_local_5()

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a,b):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_MPair(a,b))))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,fallback,fallThroughOnError = None):
        if (fallThroughOnError is None):
            fallThroughOnError = False
        def _hx_local_4():
            def _hx_local_3(cb):
                _hx_iter = HxOverrides.iterator(promises)
                next = None
                def _hx_local_2():
                    if _hx_iter.hasNext():
                        def _hx_local_1(o):
                            next1 = o.index
                            if (next1 == 0):
                                v = o.params[0]
                                def _hx_local_0(o):
                                    next1 = o.index
                                    if (next1 == 0):
                                        _g = o.params[0]
                                        next1 = _g.index
                                        if (next1 == 0):
                                            ret = _g.params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next1 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (next1 == 1):
                                        e = o.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (next1 == 1):
                                e = o.params[0]
                                if fallThroughOnError:
                                    next()
                                else:
                                    cb(tink_core_Outcome.Failure(e))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        fallback.handle(cb)
                next = _hx_local_2
                next()
            return tink_core__Future_Future_Impl_.irreversible(_hx_local_3)
        return _hx_local_4()

    @staticmethod
    def retry(gen,next):
        def _hx_local_0():
            return (python_lib_Timeit.default_timer() * 1000)
        stamp = _hx_local_0
        start = stamp()
        attempt = None
        def _hx_local_6(count):
            def _hx_local_3(error):
                def _hx_local_2():
                    def _hx_local_1(_):
                        return attempt((count + 1))
                    return tink_core__Promise_Promise_Impl_.next(next(_hx_AnonObject({'attempt': count, 'error': error, 'elapsed': (stamp() - start)})),_hx_local_1)
                return _hx_local_2()
            f = _hx_local_3
            def _hx_local_5():
                def _hx_local_4(o):
                    attempt = o.index
                    if (attempt == 0):
                        d = o.params[0]
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                    elif (attempt == 1):
                        e = o.params[0]
                        return f(e)
                    else:
                        pass
                return tink_core__Future_Future_Impl_.flatMap(gen(),_hx_local_4)
            return _hx_local_5()
        attempt = _hx_local_6
        return attempt(1)

    @staticmethod
    def ofSpecific(s):
        return s

    @staticmethod
    def fromNever(l):
        return l

    @staticmethod
    def ofTrigger(f):
        return f

    @staticmethod
    def ofHappyTrigger(f):
        return tink_core__Future_Future_Impl_.map(f,tink_core_Outcome.Success)

    @staticmethod
    def ofFuture(f):
        return tink_core__Future_Future_Impl_.map(f,tink_core_Outcome.Success)

    @staticmethod
    def ofOutcome(o):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))

    @staticmethod
    def ofData(d):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))

    @staticmethod
    def asFuture(this1):
        return this1

    @staticmethod
    def lazy(p):
        def _hx_local_1():
            def _hx_local_0(cb):
                return tink_core__Lazy_Lazy_Impl_.get(p).handle(cb)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,concurrency = None):
        return tink_core__Promise_Promise_Impl_.many(a,concurrency)

    @staticmethod
    def many(a,concurrency = None):
        def _hx_local_2():
            def _hx_local_0(o):
                return o
            def _hx_local_1(o):
                return o
            return tink_core__Future_Future_Impl_.processMany(a,concurrency,_hx_local_0,_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def inSequence(a):
        return tink_core__Promise_Promise_Impl_.many(a,1)

    @staticmethod
    def cache(gen):
        p = None
        def _hx_local_0():
            nonlocal p
            ret = p
            if (ret is None):
                sync = False
                def _hx_local_2(o):
                    def _hx_local_1(_):
                        nonlocal p
                        nonlocal sync
                        sync = True
                        p = None
                    o.b.handle(_hx_local_1)
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(o.a)))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                if (not sync):
                    p = ret
            def _hx_local_4():
                def _hx_local_3(o):
                    nonlocal p
                    if (not tink_core_OutcomeTools.isSuccess(o)):
                        p = None
                    return o
                return tink_core__Future_Future_Impl_.map(ret,_hx_local_3)
            return _hx_local_4()
        return _hx_local_0

    @staticmethod
    def lift(p):
        return p

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()

    @staticmethod
    def resolve(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(v)))

    @staticmethod
    def reject(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x):
            return tink_core__Future_Future_Impl_.map(f(x),tink_core_Outcome.Success)
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x))))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        def _hx_local_0(v):
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        def _hx_local_0(e):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSync", "ofSafe", "ofSafeSync"]

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_Future_Impl_.map(f(x1,x2),tink_core_Outcome.Success)
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x1,x2))))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_


class tink_core__Promise_PromiseTrigger_Impl_:
    _hx_class_name = "tink.core._Promise.PromiseTrigger_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "resolve", "reject", "asPromise"]

    @staticmethod
    def _new():
        return tink_core_FutureTrigger()

    @staticmethod
    def resolve(this1,v):
        return this1.trigger(tink_core_Outcome.Success(v))

    @staticmethod
    def reject(this1,e):
        return this1.trigger(tink_core_Outcome.Failure(e))

    @staticmethod
    def asPromise(this1):
        return this1
tink_core__Promise_PromiseTrigger_Impl_._hx_class = tink_core__Promise_PromiseTrigger_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        return ([None]*1)

    @staticmethod
    def get_value(this1):
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        ret = ([None]*1)
        ret[0] = v
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_


class tink_core__Signal_Gather_Impl_:
    _hx_class_name = "tink.core._Signal.Gather_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "ofBool"]

    @staticmethod
    def _new(v):
        return v

    @staticmethod
    def ofBool(b):
        return b
tink_core__Signal_Gather_Impl_._hx_class = tink_core__Signal_Gather_Impl_


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "handle", "map", "flatMap", "filter", "select", "join", "nextTime", "pickNext", "until", "next", "noise", "gather", "create", "generate", "trigger", "ofClassical", "dead"]

    @staticmethod
    def _new(f,init = None):
        return tink_core__Signal_Suspendable(f,init)

    @staticmethod
    def handle(this1,handler):
        return this1.listen(handler)

    @staticmethod
    def map(this1,f,gather = None):
        def _hx_local_3():
            def _hx_local_2(fire):
                def _hx_local_1():
                    def _hx_local_0(v):
                        fire(f(v))
                    return this1.listen(_hx_local_0)
                return _hx_local_1()
            return tink_core__Signal_Suspendable.over(this1,_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def flatMap(this1,f,gather = None):
        def _hx_local_3():
            def _hx_local_2(fire):
                def _hx_local_1():
                    def _hx_local_0(v):
                        f(v).handle(fire)
                    return this1.listen(_hx_local_0)
                return _hx_local_1()
            return tink_core__Signal_Suspendable.over(this1,_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def filter(this1,f,gather = None):
        def _hx_local_3():
            def _hx_local_2(fire):
                def _hx_local_1():
                    def _hx_local_0(v):
                        if f(v):
                            fire(v)
                    return this1.listen(_hx_local_0)
                return _hx_local_1()
            return tink_core__Signal_Suspendable.over(this1,_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def select(this1,selector,gather = None):
        def _hx_local_3():
            def _hx_local_2(fire):
                def _hx_local_1():
                    def _hx_local_0(v):
                        _g = selector(v)
                        if (_g.index == 0):
                            v = _g.params[0]
                            fire(v)
                    return this1.listen(_hx_local_0)
                return _hx_local_1()
            return tink_core__Signal_Suspendable.over(this1,_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def join(this1,that,gather = None):
        if this1.get_disposed():
            return that
        elif that.get_disposed():
            return this1
        else:
            def _hx_local_3():
                def _hx_local_0(fire):
                    cb = fire
                    return tink_core__Callback_LinkPair(this1.listen(cb),that.listen(cb))
                def _hx_local_2(_hx_self):
                    def _hx_local_1():
                        if (this1.get_disposed() and that.get_disposed()):
                            _hx_self.dispose()
                    release = _hx_local_1
                    this1.ondispose(release)
                    that.ondispose(release)
                return tink_core__Signal_Suspendable(_hx_local_0,_hx_local_2)
            return _hx_local_3()

    @staticmethod
    def nextTime(this1,condition = None):
        def _hx_local_1():
            def _hx_local_0(v):
                if ((condition is None) or condition(v)):
                    return haxe_ds_Option.Some(v)
                else:
                    return haxe_ds_Option._hx_None
            return tink_core__Signal_Signal_Impl_.pickNext(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def pickNext(this1,selector):
        ret = tink_core_FutureTrigger()
        link = None
        def _hx_local_0(v):
            _g = selector(v)
            link = _g.index
            if (link == 0):
                v = _g.params[0]
                ret.trigger(v)
            elif (link == 1):
                pass
            else:
                pass
        link = this1.listen(_hx_local_0)
        tmp = None
        if (link is None):
            def _hx_local_1(_):
                tink_core__Callback_CallbackLink_Impl_.noop()
            tmp = _hx_local_1
        else:
            f = link.cancel
            def _hx_local_2(_):
                f()
            tmp = _hx_local_2
        ret.handle(tmp)
        return ret

    @staticmethod
    def until(this1,end):
        def _hx_local_3():
            def _hx_local_0(_hx_yield):
                return this1.listen(_hx_yield)
            def _hx_local_2(_hx_self):
                f = _hx_self.dispose
                def _hx_local_1(_):
                    f()
                tmp = _hx_local_1
                end.handle(tmp)
            return tink_core__Signal_Suspendable(_hx_local_0,_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def next(this1,condition = None):
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(_):
                return None
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        return this1

    @staticmethod
    def create(f):
        return tink_core__Signal_Suspendable(f,None)

    @staticmethod
    def generate(generator,init = None):
        def _hx_local_1():
            def _hx_local_0(fire):
                generator(fire)
                return None
            return tink_core__Signal_Suspendable(_hx_local_0,init)
        return _hx_local_1()

    @staticmethod
    def trigger():
        return tink_core_SignalTrigger()

    @staticmethod
    def ofClassical(add,remove,gather = None):
        def _hx_local_3():
            def _hx_local_2(fire):
                add(fire)
                _g = remove
                a1 = fire
                def _hx_local_1():
                    def _hx_local_0():
                        _g(a1)
                    return tink_core_SimpleLink(_hx_local_0)
                return _hx_local_1()
            return tink_core__Signal_Suspendable(_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def dead():
        return tink_core__Signal_Disposed.INST
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_


class tink_core__Signal_SignalObject:
    _hx_class_name = "tink.core._Signal.SignalObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["listen"]
    _hx_interfaces = [tink_core_Disposable]
tink_core__Signal_SignalObject._hx_class = tink_core__Signal_SignalObject


class tink_core__Signal_Disposed(tink_core_AlreadyDisposed):
    _hx_class_name = "tink.core._Signal.Disposed"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["listen"]
    _hx_statics = ["INST"]
    _hx_interfaces = [tink_core__Signal_SignalObject]
    _hx_super = tink_core_AlreadyDisposed


    def __init__(self):
        super().__init__()

    def listen(self,cb):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_core__Signal_Disposed._hx_class = tink_core__Signal_Disposed


class tink_core__Signal_Suspendable:
    _hx_class_name = "tink.core._Signal.Suspendable"
    _hx_is_interface = "False"
    __slots__ = ("handlers", "activate", "init", "subscription")
    _hx_fields = ["handlers", "activate", "init", "subscription"]
    _hx_methods = ["get_disposed", "dispose", "ondispose", "listen"]
    _hx_statics = ["over"]
    _hx_interfaces = [tink_core_OwnedDisposable, tink_core__Signal_SignalObject]

    def __init__(self,activate,init = None):
        self.subscription = None
        self.init = None
        self.activate = None
        self.handlers = tink_core_CallbackList()
        _gthis = self
        self.activate = activate
        self.init = init
        def _hx_local_0():
            this1 = _gthis.subscription
            if (this1 is not None):
                this1.cancel()
        self.handlers.ondrain = _hx_local_0
        def _hx_local_1():
            nonlocal init
            if (init is not None):
                f = init
                init = None
                f(_gthis)
            _gthis.subscription = activate(_gthis.handlers.invoke)
        self.handlers.onfill = _hx_local_1

    def get_disposed(self):
        return (self.handlers.disposeHandlers is None)

    def dispose(self):
        self.handlers.dispose()

    def ondispose(self,handler):
        self.handlers.ondispose(handler)

    def listen(self,cb):
        _this = self.handlers
        if (_this.disposeHandlers is None):
            return None
        else:
            node = tink_core__Callback_ListCell(cb,_this)
            _this1 = _this.cells
            _this1.append(node)
            def _hx_local_1():
                _hx_local_0 = _this.used
                _this.used = (_this.used + 1)
                return _hx_local_0
            tmp = (_hx_local_1() == 0)
            if tmp:
                fn = _this.onfill
                if (tink_core__Callback_Callback_Impl_.depth < 100):
                    _hx_local_2 = tink_core__Callback_Callback_Impl_
                    _hx_local_3 = _hx_local_2.depth
                    _hx_local_2.depth = (_hx_local_3 + 1)
                    _hx_local_3
                    fn()
                    _hx_local_4 = tink_core__Callback_Callback_Impl_
                    _hx_local_5 = _hx_local_4.depth
                    _hx_local_4.depth = (_hx_local_5 - 1)
                    _hx_local_5
                else:
                    tink_core__Callback_Callback_Impl_.defer(fn)
            return node

    @staticmethod
    def over(s,activate):
        if s.get_disposed():
            return tink_core__Signal_Signal_Impl_.dead()
        else:
            ret = tink_core__Signal_Suspendable(activate)
            s.ondispose(ret.dispose)
            return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handlers = None
        _hx_o.activate = None
        _hx_o.init = None
        _hx_o.subscription = None
tink_core__Signal_Suspendable._hx_class = tink_core__Signal_Suspendable


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    _hx_is_interface = "False"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["get_disposed", "dispose", "ondispose", "trigger", "getLength", "listen", "clear", "asSignal"]
    _hx_interfaces = [tink_core_OwnedDisposable, tink_core__Signal_SignalObject]

    def __init__(self):
        self.handlers = tink_core_CallbackList()

    def get_disposed(self):
        return (self.handlers.disposeHandlers is None)

    def dispose(self):
        self.handlers.dispose()

    def ondispose(self,d):
        self.handlers.ondispose(d)

    def trigger(self,event):
        self.handlers.invoke(event)

    def getLength(self):
        return self.handlers.used

    def listen(self,cb):
        _this = self.handlers
        if (_this.disposeHandlers is None):
            return None
        else:
            node = tink_core__Callback_ListCell(cb,_this)
            _this1 = _this.cells
            _this1.append(node)
            def _hx_local_1():
                _hx_local_0 = _this.used
                _this.used = (_this.used + 1)
                return _hx_local_0
            tmp = (_hx_local_1() == 0)
            if tmp:
                fn = _this.onfill
                if (tink_core__Callback_Callback_Impl_.depth < 100):
                    _hx_local_2 = tink_core__Callback_Callback_Impl_
                    _hx_local_3 = _hx_local_2.depth
                    _hx_local_2.depth = (_hx_local_3 + 1)
                    _hx_local_3
                    fn()
                    _hx_local_4 = tink_core__Callback_Callback_Impl_
                    _hx_local_5 = _hx_local_4.depth
                    _hx_local_4.depth = (_hx_local_5 - 1)
                    _hx_local_5
                else:
                    tink_core__Callback_Callback_Impl_.defer(fn)
            return node

    def clear(self):
        self.handlers.clear()

    def asSignal(self):
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handlers = None
tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger


class tink_json__Char_Char_Impl_:
    _hx_class_name = "tink.json._Char.Char_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        return "".join(map(chr,[this1]))
tink_json__Char_Char_Impl_._hx_class = tink_json__Char_Char_Impl_


class tink_json_Parser:
    _hx_class_name = "tink.json.Parser"
    _hx_is_interface = "False"
    __slots__ = ()
tink_json_Parser._hx_class = tink_json_Parser


class tink_json__Parser_RawData_Impl_:
    _hx_class_name = "tink.json._Parser.RawData_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "hasBackslash", "getChar", "charPos", "hasId"]

    @staticmethod
    def _new(s,setLength):
        setLength(len(s))
        return s

    @staticmethod
    def hasBackslash(this1,_hx_min,_hx_max):
        _g = _hx_min
        _g1 = _hx_max
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 92):
                return True
        return False

    @staticmethod
    def getChar(this1,i):
        if (i >= len(this1)):
            return -1
        else:
            return ord(this1[i])

    @staticmethod
    def charPos(this1,char,start,end):
        if (start is None):
            return this1.find(char)
        else:
            return HxString.indexOfImpl(this1,char,start)

    @staticmethod
    def hasId(this1,s,_hx_min,_hx_max):
        return (HxString.substring(this1,_hx_min,_hx_max) == s)
tink_json__Parser_RawData_Impl_._hx_class = tink_json__Parser_RawData_Impl_


class tink_json__Parser_Char_Impl_:
    _hx_class_name = "tink.json._Parser.Char_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new"]

    @staticmethod
    def _new(code):
        return "".join(map(chr,[code]))
tink_json__Parser_Char_Impl_._hx_class = tink_json__Parser_Char_Impl_


class tink_json__Parser_SliceData:
    _hx_class_name = "tink.json._Parser.SliceData"
    _hx_is_interface = "False"
    __slots__ = ("source", "min", "max")
    _hx_fields = ["source", "min", "max"]

    def __init__(self,source,_hx_min,_hx_max):
        self.source = source
        self.min = _hx_min
        self.max = _hx_max

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.source = None
        _hx_o.min = None
        _hx_o.max = None
tink_json__Parser_SliceData._hx_class = tink_json__Parser_SliceData


class tink_json__Parser_JsonString_Impl_:
    _hx_class_name = "tink.json._Parser.JsonString_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toString", "get", "toInt", "toUInt", "toFloat", "equalsString"]

    @staticmethod
    def _new(raw,_hx_min,_hx_max):
        return tink_json__Parser_SliceData(raw,_hx_min,_hx_max)

    @staticmethod
    def toString(this1):
        if tink_json__Parser_RawData_Impl_.hasBackslash(this1.source,this1.min,this1.max):
            return haxe_format_JsonParser(HxString.substring(this1.source,(this1.min - 1),(this1.max + 1))).doParse()
        else:
            return HxString.substring(this1.source,this1.min,this1.max)

    @staticmethod
    def get(this1):
        return HxString.substring(this1.source,this1.min,this1.max)

    @staticmethod
    def toInt(this1):
        return Std.parseInt(HxString.substring(this1.source,this1.min,this1.max))

    @staticmethod
    def toUInt(this1):
        ret = 0
        v = HxString.substring(this1.source,this1.min,this1.max)
        _g = 0
        _g1 = len(v)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b = Std.parseInt(("" if (((i < 0) or ((i >= len(v))))) else v[i]))
            x = Math.pow(10,((len(v) - i) - 1))
            b1 = None
            try:
                b1 = int(x)
            except BaseException as _g2:
                None
                b1 = None
            ret = (ret + (b * b1))
        return ret

    @staticmethod
    def toFloat(this1):
        return Std.parseFloat(HxString.substring(this1.source,this1.min,this1.max))

    @staticmethod
    def equalsString(a,b):
        if (len(b) == ((a.max - a.min))):
            return (HxString.substring(a.source,a.min,a.max) == b)
        else:
            return False
tink_json__Parser_JsonString_Impl_._hx_class = tink_json__Parser_JsonString_Impl_


class tink_json_BasicParser:
    _hx_class_name = "tink.json.BasicParser"
    _hx_is_interface = "False"
    __slots__ = ("plugins", "source", "pos", "max", "afterParsing")
    _hx_fields = ["plugins", "source", "pos", "max", "afterParsing"]
    _hx_methods = ["init", "skipIgnored", "parseDynamic", "copyFields", "emptyInstance", "parseString", "parseRestOfString", "skipString", "parseNumber", "doParseNumber", "invalidNumber", "skipNumber", "slice", "next", "toChar", "parseSerialized", "parseValue", "skipArray", "skipValue", "invalidChar", "die", "parseBool"]
    _hx_statics = ["DBQT", "isDigit", "startsNumber"]

    def __init__(self):
        self.max = None
        self.pos = None
        self.source = None
        self.plugins = None
        self.afterParsing = list()
        self.plugins = tink_core_Annex(self)

    def init(self,source):
        self.pos = 0
        self.max = len(source)
        self.source = source
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1

    def skipIgnored(self):
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1

    def parseDynamic(self):
        start = self.pos
        self.skipValue()
        return haxe_format_JsonParser(HxString.substring(self.source,start,self.pos)).doParse()

    def copyFields(self,target,source):
        _g = 0
        _g1 = python_Boot.fields(source)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(source,f)
            setattr(target,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        return target

    def emptyInstance(self,cls):
        return Type.createEmptyInstance(cls)

    def parseString(self):
        while True:
            e = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                e = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                e = False
            if (not e):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
        e = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 34):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_2.pos
            e = True
        else:
            e = False
        e1 = (self.die(("Expected " + "string")) if ((not e)) else None)
        return self.parseRestOfString()

    def parseRestOfString(self):
        return self.slice(self.skipString(),(self.pos - 1))

    def skipString(self):
        start = self.pos
        while True:
            this1 = self.source
            char = tink_json_BasicParser.DBQT
            start1 = self.pos
            end = self.max
            _g = (this1.find(char) if ((start1 is None)) else HxString.indexOfImpl(this1,char,start1))
            if (_g == -1):
                self.die("unterminated string",start)
            else:
                v = _g
                self.pos = (v + 1)
                p = (self.pos - 2)
                while True:
                    this2 = self.source
                    if (not ((((-1 if ((p >= len(this2))) else ord(this2[p]))) == 92))):
                        break
                    p = (p - 1)
                if ((((p - self.pos) & 1)) == 0):
                    break
        return start

    def parseNumber(self):
        this1 = self.source
        i = self.pos
        char = (-1 if ((i >= len(this1))) else ord(this1[i]))
        if (((char == 46) or ((char == 45))) or (((char < 58) and ((char > 47))))):
            return self.doParseNumber()
        else:
            return self.die("number expected")

    def doParseNumber(self):
        this1 = self.source
        i = self.pos
        self.pos = (self.pos + 1)
        return self.slice(self.skipNumber((-1 if ((i >= len(this1))) else ord(this1[i]))),self.pos)

    def invalidNumber(self,start):
        return self.die(("Invalid number " + HxOverrides.stringOrNull(HxString.substring(self.source,start,self.pos))),start)

    def skipNumber(self,c):
        start = (self.pos - 1)
        minus = (c == 45)
        digit = (not minus)
        zero = (c == 48)
        point = False
        e = False
        pm = False
        end = False
        while (self.pos < self.max):
            this1 = self.source
            i = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((i >= len(this1))) else ord(this1[i]))
            c1 = c
            if ((c1 == 45) or ((c1 == 43))):
                if ((not e) or pm):
                    self.invalidNumber(start)
                digit = False
                pm = True
            elif (c1 == 46):
                if (minus or point):
                    self.invalidNumber(start)
                digit = False
                point = True
            elif (c1 == 48):
                if (zero and (not point)):
                    self.invalidNumber(start)
                if minus:
                    minus = False
                    zero = True
                digit = True
            elif (((((((((c1 == 57) or ((c1 == 56))) or ((c1 == 55))) or ((c1 == 54))) or ((c1 == 53))) or ((c1 == 52))) or ((c1 == 51))) or ((c1 == 50))) or ((c1 == 49))):
                if (zero and (not point)):
                    self.invalidNumber(start)
                if minus:
                    minus = False
                digit = True
                zero = False
            elif ((c1 == 101) or ((c1 == 69))):
                if ((minus or zero) or e):
                    self.invalidNumber(start)
                digit = False
                e = True
            else:
                if (not digit):
                    self.invalidNumber(start)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 - 1)
                _hx_local_1
                end = True
            if end:
                break
        return start

    def slice(self,_hx_from,to):
        return tink_json__Parser_SliceData(self.source,_hx_from,to)

    def next(self):
        this1 = self.source
        i = self.pos
        self.pos = (self.pos + 1)
        if (i >= len(this1)):
            return -1
        else:
            return ord(this1[i])

    def toChar(self,code,expected):
        while True:
            this1 = self.source
            i = self.pos
            self.pos = (self.pos + 1)
            _g = (-1 if ((i >= len(this1))) else ord(this1[i]))
            _hx_tmp = None
            if ((_g == code) == True):
                break
            else:
                _hx_tmp = (_g < 33)
                if (_hx_tmp != True):
                    self.die(("expected " + ("null" if expected is None else expected)))

    def parseSerialized(self):
        start = self.pos
        self.skipValue()
        return HxString.substring(self.source,start,self.pos)

    def parseValue(self):
        _gthis = self
        this1 = self.source
        i = self.pos
        self.pos = (self.pos + 1)
        _g = (-1 if ((i >= len(this1))) else ord(this1[i]))
        _g1 = _g
        if (_g1 == 34):
            return tink_json_Value.VString(tink_json__Parser_JsonString_Impl_.toString(self.parseRestOfString()))
        elif (_g1 == 91):
            ret = list()
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + 1)
                _hx_local_2.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + 1)
                    _hx_local_5
                tmp = True
            else:
                tmp = False
            if (not tmp):
                while True:
                    x = self.parseValue()
                    ret.append(x)
                    while True:
                        tmp = None
                        if (self.pos < self.max):
                            this1 = self.source
                            i = self.pos
                            tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        _hx_local_6 = self
                        _hx_local_7 = _hx_local_6.pos
                        _hx_local_6.pos = (_hx_local_7 + 1)
                        _hx_local_7
                    tmp1 = None
                    this2 = self.source
                    i1 = self.pos
                    if (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) == 44):
                        _hx_local_8 = self
                        _hx_local_9 = _hx_local_8.pos
                        _hx_local_8.pos = (_hx_local_9 + 1)
                        _hx_local_8.pos
                        while True:
                            tmp2 = None
                            if (self.pos < self.max):
                                this3 = self.source
                                i2 = self.pos
                                tmp2 = (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) < 33)
                            else:
                                tmp2 = False
                            if (not tmp2):
                                break
                            _hx_local_10 = self
                            _hx_local_11 = _hx_local_10.pos
                            _hx_local_10.pos = (_hx_local_11 + 1)
                            _hx_local_11
                        tmp1 = True
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                while True:
                    tmp = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.pos
                    _hx_local_12.pos = (_hx_local_13 + 1)
                    _hx_local_13
                tmp = None
                this1 = self.source
                i = self.pos
                if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 + 1)
                    _hx_local_14.pos
                    tmp = True
                else:
                    tmp = False
                if (not tmp):
                    self.die(("Expected " + "]"))
            return tink_json_Value.VArray(ret)
        elif (_g1 == 102):
            e = None
            e1 = None
            e2 = None
            e3 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 97):
                this1 = self.source
                i = (self.pos + 1)
                e3 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                e3 = False
            if e3:
                this1 = self.source
                i = (self.pos + 2)
                e2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 115)
            else:
                e2 = False
            if e2:
                this1 = self.source
                i = (self.pos + 3)
                e1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
            else:
                e1 = False
            if e1:
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.pos
                _hx_local_16.pos = (_hx_local_17 + 4)
                _hx_local_16.pos
                e = True
            else:
                e = False
            e1 = (self.die(("Expected " + "alse")) if ((not e)) else None)
            return tink_json_Value.VBool(False)
        elif (_g1 == 110):
            e = None
            e1 = None
            e2 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 117):
                this1 = self.source
                i = (self.pos + 1)
                e2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                e2 = False
            if e2:
                this1 = self.source
                i = (self.pos + 2)
                e1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                e1 = False
            if e1:
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.pos
                _hx_local_18.pos = (_hx_local_19 + 3)
                _hx_local_18.pos
                e = True
            else:
                e = False
            e1 = (self.die(("Expected " + "ull")) if ((not e)) else None)
            return tink_json_Value.VNull
        elif (_g1 == 116):
            e = None
            e1 = None
            e2 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 114):
                this1 = self.source
                i = (self.pos + 1)
                e2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 117)
            else:
                e2 = False
            if e2:
                this1 = self.source
                i = (self.pos + 2)
                e1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
            else:
                e1 = False
            if e1:
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.pos
                _hx_local_20.pos = (_hx_local_21 + 3)
                _hx_local_20.pos
                e = True
            else:
                e = False
            e1 = (self.die(("Expected " + "rue")) if ((not e)) else None)
            return tink_json_Value.VBool(True)
        elif (_g1 == 123):
            fields = list()
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_22 = self
                _hx_local_23 = _hx_local_22.pos
                _hx_local_22.pos = (_hx_local_23 + 1)
                _hx_local_23
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 125):
                _hx_local_24 = self
                _hx_local_25 = _hx_local_24.pos
                _hx_local_24.pos = (_hx_local_25 + 1)
                _hx_local_24.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.pos
                    _hx_local_26.pos = (_hx_local_27 + 1)
                    _hx_local_27
                tmp = True
            else:
                tmp = False
            if (not tmp):
                while True:
                    this1 = _gthis.source
                    def _hx_local_29():
                        _hx_local_28 = _gthis.pos
                        _gthis.pos = (_gthis.pos + 1)
                        return _hx_local_28
                    i = _hx_local_29()
                    if (((-1 if ((i >= len(this1))) else ord(this1[i]))) != 34):
                        _gthis.die("expected string",(_gthis.pos - 1))
                    x = tink_json__Parser_JsonString_Impl_.toString(_gthis.parseRestOfString())
                    while True:
                        e = None
                        if (_gthis.pos < _gthis.max):
                            this2 = _gthis.source
                            i1 = _gthis.pos
                            e = (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) < 33)
                        else:
                            e = False
                        if (not e):
                            break
                        _gthis.pos = (_gthis.pos + 1)
                    e1 = None
                    this3 = _gthis.source
                    i2 = _gthis.pos
                    if (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) == 58):
                        _gthis.pos = (_gthis.pos + 1)
                        while True:
                            e2 = None
                            if (_gthis.pos < _gthis.max):
                                this4 = _gthis.source
                                i3 = _gthis.pos
                                e2 = (((-1 if ((i3 >= len(this4))) else ord(this4[i3]))) < 33)
                            else:
                                e2 = False
                            if (not e2):
                                break
                            _gthis.pos = (_gthis.pos + 1)
                        e1 = True
                    else:
                        e1 = False
                    e3 = (_gthis.die(("Expected " + ":")) if ((not e1)) else None)
                    x1 = tink_core_NamedWith(x,_gthis.parseValue())
                    fields.append(x1)
                    while True:
                        tmp = None
                        if (self.pos < self.max):
                            this5 = self.source
                            i4 = self.pos
                            tmp = (((-1 if ((i4 >= len(this5))) else ord(this5[i4]))) < 33)
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        _hx_local_33 = self
                        _hx_local_34 = _hx_local_33.pos
                        _hx_local_33.pos = (_hx_local_34 + 1)
                        _hx_local_34
                    tmp1 = None
                    this6 = self.source
                    i5 = self.pos
                    if (((-1 if ((i5 >= len(this6))) else ord(this6[i5]))) == 44):
                        _hx_local_35 = self
                        _hx_local_36 = _hx_local_35.pos
                        _hx_local_35.pos = (_hx_local_36 + 1)
                        _hx_local_35.pos
                        while True:
                            tmp2 = None
                            if (self.pos < self.max):
                                this7 = self.source
                                i6 = self.pos
                                tmp2 = (((-1 if ((i6 >= len(this7))) else ord(this7[i6]))) < 33)
                            else:
                                tmp2 = False
                            if (not tmp2):
                                break
                            _hx_local_37 = self
                            _hx_local_38 = _hx_local_37.pos
                            _hx_local_37.pos = (_hx_local_38 + 1)
                            _hx_local_38
                        tmp1 = True
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                while True:
                    tmp = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _hx_local_39 = self
                    _hx_local_40 = _hx_local_39.pos
                    _hx_local_39.pos = (_hx_local_40 + 1)
                    _hx_local_40
                tmp = None
                this1 = self.source
                i = self.pos
                if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 125):
                    _hx_local_41 = self
                    _hx_local_42 = _hx_local_41.pos
                    _hx_local_41.pos = (_hx_local_42 + 1)
                    _hx_local_41.pos
                    tmp = True
                else:
                    tmp = False
                if (not tmp):
                    self.die(("Expected " + "}"))
            return tink_json_Value.VObject(fields)
        else:
            char = _g
            if (((char == 46) or ((char == 45))) or (((char < 58) and ((char > 47))))):
                _hx_local_43 = self
                _hx_local_44 = _hx_local_43.pos
                _hx_local_43.pos = (_hx_local_44 - 1)
                _hx_local_44
                this1 = self.doParseNumber()
                return tink_json_Value.VNumber(Std.parseFloat(HxString.substring(this1.source,this1.min,this1.max)))
            else:
                return self.invalidChar(char)

    def skipArray(self):
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_2.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 + 1)
                _hx_local_5
            tmp = True
        else:
            tmp = False
        if tmp:
            return
        while True:
            self.skipValue()
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.pos
                _hx_local_6.pos = (_hx_local_7 + 1)
                _hx_local_7
            tmp1 = None
            this2 = self.source
            i1 = self.pos
            if (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) == 44):
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 1)
                _hx_local_8.pos
                while True:
                    tmp2 = None
                    if (self.pos < self.max):
                        this3 = self.source
                        i2 = self.pos
                        tmp2 = (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) < 33)
                    else:
                        tmp2 = False
                    if (not tmp2):
                        break
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.pos
                    _hx_local_10.pos = (_hx_local_11 + 1)
                    _hx_local_11
                tmp1 = True
            else:
                tmp1 = False
            if (not tmp1):
                break
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 1)
            _hx_local_13
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.pos
            _hx_local_14.pos = (_hx_local_15 + 1)
            _hx_local_14.pos
            tmp = True
        else:
            tmp = False
        if (not tmp):
            self.die(("Expected " + "]"))

    def skipValue(self):
        _gthis = self
        this1 = self.source
        i = self.pos
        self.pos = (self.pos + 1)
        _g = (-1 if ((i >= len(this1))) else ord(this1[i]))
        _g1 = _g
        if (_g1 == 34):
            self.skipString()
        elif (_g1 == 91):
            self.skipArray()
        elif (_g1 == 102):
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 97):
                this1 = self.source
                i = (self.pos + 1)
                tmp3 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                tmp3 = False
            if tmp3:
                this1 = self.source
                i = (self.pos + 2)
                tmp2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 115)
            else:
                tmp2 = False
            if tmp2:
                this1 = self.source
                i = (self.pos + 3)
                tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
            else:
                tmp1 = False
            if tmp1:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 4)
                _hx_local_0.pos
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "alse"))
        elif (_g1 == 110):
            tmp = None
            tmp1 = None
            tmp2 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 117):
                this1 = self.source
                i = (self.pos + 1)
                tmp2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                tmp2 = False
            if tmp2:
                this1 = self.source
                i = (self.pos + 2)
                tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                tmp1 = False
            if tmp1:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + 3)
                _hx_local_2.pos
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "ull"))
        elif (_g1 == 116):
            tmp = None
            tmp1 = None
            tmp2 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 114):
                this1 = self.source
                i = (self.pos + 1)
                tmp2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 117)
            else:
                tmp2 = False
            if tmp2:
                this1 = self.source
                i = (self.pos + 2)
                tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
            else:
                tmp1 = False
            if tmp1:
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 + 3)
                _hx_local_4.pos
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "rue"))
        elif (_g1 == 123):
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.pos
                _hx_local_6.pos = (_hx_local_7 + 1)
                _hx_local_7
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 125):
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 1)
                _hx_local_8.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.pos
                    _hx_local_10.pos = (_hx_local_11 + 1)
                    _hx_local_11
                tmp = True
            else:
                tmp = False
            if tmp:
                return
            while True:
                this1 = _gthis.source
                def _hx_local_13():
                    _hx_local_12 = _gthis.pos
                    _gthis.pos = (_gthis.pos + 1)
                    return _hx_local_12
                i = _hx_local_13()
                if (((-1 if ((i >= len(this1))) else ord(this1[i]))) != 34):
                    _gthis.die("expected string",(_gthis.pos - 1))
                _gthis.skipString()
                while True:
                    tmp = None
                    if (_gthis.pos < _gthis.max):
                        this2 = _gthis.source
                        i1 = _gthis.pos
                        tmp = (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _gthis.pos = (_gthis.pos + 1)
                tmp1 = None
                this3 = _gthis.source
                i2 = _gthis.pos
                if (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) == 58):
                    _gthis.pos = (_gthis.pos + 1)
                    while True:
                        tmp2 = None
                        if (_gthis.pos < _gthis.max):
                            this4 = _gthis.source
                            i3 = _gthis.pos
                            tmp2 = (((-1 if ((i3 >= len(this4))) else ord(this4[i3]))) < 33)
                        else:
                            tmp2 = False
                        if (not tmp2):
                            break
                        _gthis.pos = (_gthis.pos + 1)
                    tmp1 = True
                else:
                    tmp1 = False
                if (not tmp1):
                    _gthis.die(("Expected " + ":"))
                _gthis.skipValue()
                while True:
                    tmp3 = None
                    if (self.pos < self.max):
                        this5 = self.source
                        i4 = self.pos
                        tmp3 = (((-1 if ((i4 >= len(this5))) else ord(this5[i4]))) < 33)
                    else:
                        tmp3 = False
                    if (not tmp3):
                        break
                    _hx_local_17 = self
                    _hx_local_18 = _hx_local_17.pos
                    _hx_local_17.pos = (_hx_local_18 + 1)
                    _hx_local_18
                tmp4 = None
                this6 = self.source
                i5 = self.pos
                if (((-1 if ((i5 >= len(this6))) else ord(this6[i5]))) == 44):
                    _hx_local_19 = self
                    _hx_local_20 = _hx_local_19.pos
                    _hx_local_19.pos = (_hx_local_20 + 1)
                    _hx_local_19.pos
                    while True:
                        tmp5 = None
                        if (self.pos < self.max):
                            this7 = self.source
                            i6 = self.pos
                            tmp5 = (((-1 if ((i6 >= len(this7))) else ord(this7[i6]))) < 33)
                        else:
                            tmp5 = False
                        if (not tmp5):
                            break
                        _hx_local_21 = self
                        _hx_local_22 = _hx_local_21.pos
                        _hx_local_21.pos = (_hx_local_22 + 1)
                        _hx_local_22
                    tmp4 = True
                else:
                    tmp4 = False
                if (not tmp4):
                    break
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_23 = self
                _hx_local_24 = _hx_local_23.pos
                _hx_local_23.pos = (_hx_local_24 + 1)
                _hx_local_24
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 125):
                _hx_local_25 = self
                _hx_local_26 = _hx_local_25.pos
                _hx_local_25.pos = (_hx_local_26 + 1)
                _hx_local_25.pos
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "}"))
        else:
            char = _g
            if (((char == 46) or ((char == 45))) or (((char < 58) and ((char > 47))))):
                self.skipNumber(char)
            else:
                self.invalidChar(char)

    def invalidChar(self,c):
        return self.die(("invalid char " + HxOverrides.stringOrNull(StringTools.hex(c,2))),(self.pos - 1))

    def die(self,s,pos = None,end = None):
        if (pos is None):
            pos = -1
        if (end is None):
            end = -1
        if (pos == -1):
            pos = self.pos
            end = pos
        elif (end == -1):
            end = self.pos
        if (end <= pos):
            end = (pos + 1)
        range = (((("characters " + Std.string(pos)) + " - ") + Std.string(end)) if ((end > ((pos + 1)))) else ("character " + Std.string(pos)))
        def _hx_local_0(s,maxLength,left):
            if (len(s) > maxLength):
                if left:
                    return ("... " + HxOverrides.stringOrNull(HxString.substr(s,(len(s) - maxLength),None)))
                else:
                    return (HxOverrides.stringOrNull(HxString.substr(s,0,maxLength)) + " ...")
            else:
                return s
        clip = _hx_local_0
        center = ((pos + end) >> 1)
        context = (((((HxOverrides.stringOrNull(clip(HxString.substring(self.source,0,pos),20,True)) + "  ---->  ") + HxOverrides.stringOrNull(clip(HxString.substring(self.source,pos,center),20,False))) + HxOverrides.stringOrNull(clip(HxString.substring(self.source,center,end),20,True))) + "  <----  ") + HxOverrides.stringOrNull(clip(HxString.substring(self.source,end,self.max),20,False)))
        return tink_core_TypedError.withData(422,(("null" if s is None else s) + HxOverrides.stringOrNull(((((" at " + ("null" if range is None else range)) + " in ") + ("null" if context is None else context))))),_hx_AnonObject({'source': self.source, 'start': pos, 'end': end}),_hx_AnonObject({'fileName': "tink/json/Parser.hx", 'lineNumber': 472, 'className': "tink.json.BasicParser", 'methodName': "die"})).throwSelf()

    def parseBool(self):
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 116):
            this1 = self.source
            i = (self.pos + 1)
            tmp3 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 114)
        else:
            tmp3 = False
        if tmp3:
            this1 = self.source
            i = (self.pos + 2)
            tmp2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 117)
        else:
            tmp2 = False
        if tmp2:
            this1 = self.source
            i = (self.pos + 3)
            tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
        else:
            tmp1 = False
        if tmp1:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 4)
            _hx_local_2.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 + 1)
                _hx_local_5
            tmp = True
        else:
            tmp = False
        if tmp:
            return True
        else:
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.pos
                _hx_local_6.pos = (_hx_local_7 + 1)
                _hx_local_7
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            tmp4 = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 102):
                this1 = self.source
                i = (self.pos + 1)
                tmp4 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 97)
            else:
                tmp4 = False
            if tmp4:
                this1 = self.source
                i = (self.pos + 2)
                tmp3 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 108)
            else:
                tmp3 = False
            if tmp3:
                this1 = self.source
                i = (self.pos + 3)
                tmp2 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 115)
            else:
                tmp2 = False
            if tmp2:
                this1 = self.source
                i = (self.pos + 4)
                tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 101)
            else:
                tmp1 = False
            if tmp1:
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 5)
                _hx_local_8.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.pos
                    _hx_local_10.pos = (_hx_local_11 + 1)
                    _hx_local_11
                tmp = True
            else:
                tmp = False
            if tmp:
                return False
            else:
                return self.die("expected boolean value")

    @staticmethod
    def isDigit(char):
        if (char < 58):
            return (char > 47)
        else:
            return False

    @staticmethod
    def startsNumber(char):
        if (not (((char == 46) or ((char == 45))))):
            if (char < 58):
                return (char > 47)
            else:
                return False
        else:
            return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.plugins = None
        _hx_o.source = None
        _hx_o.pos = None
        _hx_o.max = None
        _hx_o.afterParsing = None
tink_json_BasicParser._hx_class = tink_json_BasicParser


class tink_json_Parser0(tink_json_BasicParser):
    _hx_class_name = "tink.json.Parser0"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["parse", "tryParse"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_json_BasicParser


    def __init__(self):
        super().__init__()

    def parse(self,source):
        _gthis = self
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        self.init(source)
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 91):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_2.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 + 1)
                _hx_local_5
            tmp = True
        else:
            tmp = False
        if (not tmp):
            self.die(("Expected " + "["))
        _hx___ret = haxe_ds_StringMap()
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_8.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.pos
                _hx_local_10.pos = (_hx_local_11 + 1)
                _hx_local_11
            tmp = True
        else:
            tmp = False
        if (not tmp):
            while True:
                while True:
                    tmp = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.pos
                    _hx_local_12.pos = (_hx_local_13 + 1)
                    _hx_local_13
                tmp1 = None
                this2 = self.source
                i1 = self.pos
                if (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) == 91):
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 + 1)
                    _hx_local_14.pos
                    while True:
                        tmp2 = None
                        if (self.pos < self.max):
                            this3 = self.source
                            i2 = self.pos
                            tmp2 = (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) < 33)
                        else:
                            tmp2 = False
                        if (not tmp2):
                            break
                        _hx_local_16 = self
                        _hx_local_17 = _hx_local_16.pos
                        _hx_local_16.pos = (_hx_local_17 + 1)
                        _hx_local_17
                    tmp1 = True
                else:
                    tmp1 = False
                if (not tmp1):
                    self.die(("Expected " + "["))
                _e0 = tink_json__Parser_JsonString_Impl_.toString(self.parseString())
                while True:
                    e = None
                    if (self.pos < self.max):
                        this4 = self.source
                        i3 = self.pos
                        e = (((-1 if ((i3 >= len(this4))) else ord(this4[i3]))) < 33)
                    else:
                        e = False
                    if (not e):
                        break
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.pos
                    _hx_local_18.pos = (_hx_local_19 + 1)
                    _hx_local_19
                e1 = None
                this5 = self.source
                i4 = self.pos
                if (((-1 if ((i4 >= len(this5))) else ord(this5[i4]))) == 44):
                    _hx_local_20 = self
                    _hx_local_21 = _hx_local_20.pos
                    _hx_local_20.pos = (_hx_local_21 + 1)
                    _hx_local_20.pos
                    while True:
                        e2 = None
                        if (self.pos < self.max):
                            this6 = self.source
                            i5 = self.pos
                            e2 = (((-1 if ((i5 >= len(this6))) else ord(this6[i5]))) < 33)
                        else:
                            e2 = False
                        if (not e2):
                            break
                        _hx_local_22 = self
                        _hx_local_23 = _hx_local_22.pos
                        _hx_local_22.pos = (_hx_local_23 + 1)
                        _hx_local_23
                    e1 = True
                else:
                    e1 = False
                e3 = (self.die(("Expected " + ",")) if ((not e1)) else None)
                while True:
                    tmp3 = None
                    if (self.pos < self.max):
                        this7 = self.source
                        i6 = self.pos
                        tmp3 = (((-1 if ((i6 >= len(this7))) else ord(this7[i6]))) < 33)
                    else:
                        tmp3 = False
                    if (not tmp3):
                        break
                    _hx_local_24 = self
                    _hx_local_25 = _hx_local_24.pos
                    _hx_local_24.pos = (_hx_local_25 + 1)
                    _hx_local_25
                tmp4 = None
                this8 = self.source
                i7 = self.pos
                if (((-1 if ((i7 >= len(this8))) else ord(this8[i7]))) == 91):
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.pos
                    _hx_local_26.pos = (_hx_local_27 + 1)
                    _hx_local_26.pos
                    while True:
                        tmp5 = None
                        if (self.pos < self.max):
                            this9 = self.source
                            i8 = self.pos
                            tmp5 = (((-1 if ((i8 >= len(this9))) else ord(this9[i8]))) < 33)
                        else:
                            tmp5 = False
                        if (not tmp5):
                            break
                        _hx_local_28 = self
                        _hx_local_29 = _hx_local_28.pos
                        _hx_local_28.pos = (_hx_local_29 + 1)
                        _hx_local_29
                    tmp4 = True
                else:
                    tmp4 = False
                if (not tmp4):
                    self.die(("Expected " + "["))
                _hx___ret1 = []
                while True:
                    tmp6 = None
                    if (self.pos < self.max):
                        this10 = self.source
                        i9 = self.pos
                        tmp6 = (((-1 if ((i9 >= len(this10))) else ord(this10[i9]))) < 33)
                    else:
                        tmp6 = False
                    if (not tmp6):
                        break
                    _hx_local_30 = self
                    _hx_local_31 = _hx_local_30.pos
                    _hx_local_30.pos = (_hx_local_31 + 1)
                    _hx_local_31
                tmp7 = None
                this11 = self.source
                i10 = self.pos
                if (((-1 if ((i10 >= len(this11))) else ord(this11[i10]))) == 93):
                    _hx_local_32 = self
                    _hx_local_33 = _hx_local_32.pos
                    _hx_local_32.pos = (_hx_local_33 + 1)
                    _hx_local_32.pos
                    while True:
                        tmp8 = None
                        if (self.pos < self.max):
                            this12 = self.source
                            i11 = self.pos
                            tmp8 = (((-1 if ((i11 >= len(this12))) else ord(this12[i11]))) < 33)
                        else:
                            tmp8 = False
                        if (not tmp8):
                            break
                        _hx_local_34 = self
                        _hx_local_35 = _hx_local_34.pos
                        _hx_local_34.pos = (_hx_local_35 + 1)
                        _hx_local_35
                    tmp7 = True
                else:
                    tmp7 = False
                if (not tmp7):
                    while True:
                        x = tink_json__Parser_JsonString_Impl_.toString(self.parseString())
                        _hx___ret1.append(x)
                        while True:
                            tmp9 = None
                            if (self.pos < self.max):
                                this13 = self.source
                                i12 = self.pos
                                tmp9 = (((-1 if ((i12 >= len(this13))) else ord(this13[i12]))) < 33)
                            else:
                                tmp9 = False
                            if (not tmp9):
                                break
                            _hx_local_36 = self
                            _hx_local_37 = _hx_local_36.pos
                            _hx_local_36.pos = (_hx_local_37 + 1)
                            _hx_local_37
                        tmp10 = None
                        this14 = self.source
                        i13 = self.pos
                        if (((-1 if ((i13 >= len(this14))) else ord(this14[i13]))) == 44):
                            _hx_local_38 = self
                            _hx_local_39 = _hx_local_38.pos
                            _hx_local_38.pos = (_hx_local_39 + 1)
                            _hx_local_38.pos
                            while True:
                                tmp11 = None
                                if (self.pos < self.max):
                                    this15 = self.source
                                    i14 = self.pos
                                    tmp11 = (((-1 if ((i14 >= len(this15))) else ord(this15[i14]))) < 33)
                                else:
                                    tmp11 = False
                                if (not tmp11):
                                    break
                                _hx_local_40 = self
                                _hx_local_41 = _hx_local_40.pos
                                _hx_local_40.pos = (_hx_local_41 + 1)
                                _hx_local_41
                            tmp10 = True
                        else:
                            tmp10 = False
                        if (not tmp10):
                            break
                    while True:
                        tmp12 = None
                        if (self.pos < self.max):
                            this16 = self.source
                            i15 = self.pos
                            tmp12 = (((-1 if ((i15 >= len(this16))) else ord(this16[i15]))) < 33)
                        else:
                            tmp12 = False
                        if (not tmp12):
                            break
                        _hx_local_42 = self
                        _hx_local_43 = _hx_local_42.pos
                        _hx_local_42.pos = (_hx_local_43 + 1)
                        _hx_local_43
                    tmp13 = None
                    this17 = self.source
                    i16 = self.pos
                    if (((-1 if ((i16 >= len(this17))) else ord(this17[i16]))) == 93):
                        _hx_local_44 = self
                        _hx_local_45 = _hx_local_44.pos
                        _hx_local_44.pos = (_hx_local_45 + 1)
                        _hx_local_44.pos
                        while True:
                            tmp14 = None
                            if (self.pos < self.max):
                                this18 = self.source
                                i17 = self.pos
                                tmp14 = (((-1 if ((i17 >= len(this18))) else ord(this18[i17]))) < 33)
                            else:
                                tmp14 = False
                            if (not tmp14):
                                break
                            _hx_local_46 = self
                            _hx_local_47 = _hx_local_46.pos
                            _hx_local_46.pos = (_hx_local_47 + 1)
                            _hx_local_47
                        tmp13 = True
                    else:
                        tmp13 = False
                    if (not tmp13):
                        self.die(("Expected " + "]"))
                _e1 = _hx___ret1
                _hx___ret.h[_e0] = _e1
                while True:
                    tmp15 = None
                    if (self.pos < self.max):
                        this19 = self.source
                        i18 = self.pos
                        tmp15 = (((-1 if ((i18 >= len(this19))) else ord(this19[i18]))) < 33)
                    else:
                        tmp15 = False
                    if (not tmp15):
                        break
                    _hx_local_48 = self
                    _hx_local_49 = _hx_local_48.pos
                    _hx_local_48.pos = (_hx_local_49 + 1)
                    _hx_local_49
                tmp16 = None
                this20 = self.source
                i19 = self.pos
                if (((-1 if ((i19 >= len(this20))) else ord(this20[i19]))) == 93):
                    _hx_local_50 = self
                    _hx_local_51 = _hx_local_50.pos
                    _hx_local_50.pos = (_hx_local_51 + 1)
                    _hx_local_50.pos
                    while True:
                        tmp17 = None
                        if (self.pos < self.max):
                            this21 = self.source
                            i20 = self.pos
                            tmp17 = (((-1 if ((i20 >= len(this21))) else ord(this21[i20]))) < 33)
                        else:
                            tmp17 = False
                        if (not tmp17):
                            break
                        _hx_local_52 = self
                        _hx_local_53 = _hx_local_52.pos
                        _hx_local_52.pos = (_hx_local_53 + 1)
                        _hx_local_53
                    tmp16 = True
                else:
                    tmp16 = False
                if (not tmp16):
                    self.die(("Expected " + "]"))
                while True:
                    tmp18 = None
                    if (self.pos < self.max):
                        this22 = self.source
                        i21 = self.pos
                        tmp18 = (((-1 if ((i21 >= len(this22))) else ord(this22[i21]))) < 33)
                    else:
                        tmp18 = False
                    if (not tmp18):
                        break
                    _hx_local_54 = self
                    _hx_local_55 = _hx_local_54.pos
                    _hx_local_54.pos = (_hx_local_55 + 1)
                    _hx_local_55
                tmp19 = None
                this23 = self.source
                i22 = self.pos
                if (((-1 if ((i22 >= len(this23))) else ord(this23[i22]))) == 44):
                    _hx_local_56 = self
                    _hx_local_57 = _hx_local_56.pos
                    _hx_local_56.pos = (_hx_local_57 + 1)
                    _hx_local_56.pos
                    while True:
                        tmp20 = None
                        if (self.pos < self.max):
                            this24 = self.source
                            i23 = self.pos
                            tmp20 = (((-1 if ((i23 >= len(this24))) else ord(this24[i23]))) < 33)
                        else:
                            tmp20 = False
                        if (not tmp20):
                            break
                        _hx_local_58 = self
                        _hx_local_59 = _hx_local_58.pos
                        _hx_local_58.pos = (_hx_local_59 + 1)
                        _hx_local_59
                    tmp19 = True
                else:
                    tmp19 = False
                if (not tmp19):
                    break
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_60 = self
                _hx_local_61 = _hx_local_60.pos
                _hx_local_60.pos = (_hx_local_61 + 1)
                _hx_local_61
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
                _hx_local_62 = self
                _hx_local_63 = _hx_local_62.pos
                _hx_local_62.pos = (_hx_local_63 + 1)
                _hx_local_62.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_64 = self
                    _hx_local_65 = _hx_local_64.pos
                    _hx_local_64.pos = (_hx_local_65 + 1)
                    _hx_local_65
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "]"))
        ret = _hx___ret
        _g = 0
        _g1 = self.afterParsing
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f()
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        return ret

    def tryParse(self,source):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                ret = _gthis.parse(source)
                while True:
                    tmp = None
                    if (_gthis.pos < _gthis.max):
                        this1 = _gthis.source
                        i = _gthis.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _gthis.pos = (_gthis.pos + 1)
                if (_gthis.pos < _gthis.max):
                    _gthis.die("Invalid data after JSON document")
                return ret
            return tink_core_TypedError.catchExceptions(_hx_local_1,None,_hx_AnonObject({'fileName': "tink/json/macros/Macro.hx", 'lineNumber': 107, 'className': "tink.json.Parser0", 'methodName': "tryParse"}))
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_json_Parser0._hx_class = tink_json_Parser0


class tink_json_Parser1(tink_json_BasicParser):
    _hx_class_name = "tink.json.Parser1"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["parse", "tryParse"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_json_BasicParser


    def __init__(self):
        super().__init__()

    def parse(self,source):
        _gthis = self
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        self.init(source)
        ret = tink_json__Parser_JsonString_Impl_.toString(self.parseString())
        _g = 0
        _g1 = self.afterParsing
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f()
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        return ret

    def tryParse(self,source):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                ret = _gthis.parse(source)
                while True:
                    tmp = None
                    if (_gthis.pos < _gthis.max):
                        this1 = _gthis.source
                        i = _gthis.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _gthis.pos = (_gthis.pos + 1)
                if (_gthis.pos < _gthis.max):
                    _gthis.die("Invalid data after JSON document")
                return ret
            return tink_core_TypedError.catchExceptions(_hx_local_1,None,_hx_AnonObject({'fileName': "tink/json/macros/Macro.hx", 'lineNumber': 107, 'className': "tink.json.Parser1", 'methodName': "tryParse"}))
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_json_Parser1._hx_class = tink_json_Parser1


class tink_json_Parser2(tink_json_BasicParser):
    _hx_class_name = "tink.json.Parser2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["parse", "tryParse"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_json_BasicParser


    def __init__(self):
        super().__init__()

    def parse(self,source):
        _gthis = self
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        self.init(source)
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 91):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_2.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 + 1)
                _hx_local_5
            tmp = True
        else:
            tmp = False
        if (not tmp):
            self.die(("Expected " + "["))
        _hx___ret = haxe_ds_StringMap()
        while True:
            tmp = None
            if (self.pos < self.max):
                this1 = self.source
                i = self.pos
                tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
            else:
                tmp = False
            if (not tmp):
                break
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
        tmp = None
        this1 = self.source
        i = self.pos
        if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_8.pos
            while True:
                tmp1 = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.pos
                _hx_local_10.pos = (_hx_local_11 + 1)
                _hx_local_11
            tmp = True
        else:
            tmp = False
        if (not tmp):
            while True:
                while True:
                    tmp = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.pos
                    _hx_local_12.pos = (_hx_local_13 + 1)
                    _hx_local_13
                tmp1 = None
                this2 = self.source
                i1 = self.pos
                if (((-1 if ((i1 >= len(this2))) else ord(this2[i1]))) == 91):
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 + 1)
                    _hx_local_14.pos
                    while True:
                        tmp2 = None
                        if (self.pos < self.max):
                            this3 = self.source
                            i2 = self.pos
                            tmp2 = (((-1 if ((i2 >= len(this3))) else ord(this3[i2]))) < 33)
                        else:
                            tmp2 = False
                        if (not tmp2):
                            break
                        _hx_local_16 = self
                        _hx_local_17 = _hx_local_16.pos
                        _hx_local_16.pos = (_hx_local_17 + 1)
                        _hx_local_17
                    tmp1 = True
                else:
                    tmp1 = False
                if (not tmp1):
                    self.die(("Expected " + "["))
                _e0 = tink_json__Parser_JsonString_Impl_.toString(self.parseString())
                while True:
                    e = None
                    if (self.pos < self.max):
                        this4 = self.source
                        i3 = self.pos
                        e = (((-1 if ((i3 >= len(this4))) else ord(this4[i3]))) < 33)
                    else:
                        e = False
                    if (not e):
                        break
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.pos
                    _hx_local_18.pos = (_hx_local_19 + 1)
                    _hx_local_19
                e1 = None
                this5 = self.source
                i4 = self.pos
                if (((-1 if ((i4 >= len(this5))) else ord(this5[i4]))) == 44):
                    _hx_local_20 = self
                    _hx_local_21 = _hx_local_20.pos
                    _hx_local_20.pos = (_hx_local_21 + 1)
                    _hx_local_20.pos
                    while True:
                        e2 = None
                        if (self.pos < self.max):
                            this6 = self.source
                            i5 = self.pos
                            e2 = (((-1 if ((i5 >= len(this6))) else ord(this6[i5]))) < 33)
                        else:
                            e2 = False
                        if (not e2):
                            break
                        _hx_local_22 = self
                        _hx_local_23 = _hx_local_22.pos
                        _hx_local_22.pos = (_hx_local_23 + 1)
                        _hx_local_23
                    e1 = True
                else:
                    e1 = False
                e3 = (self.die(("Expected " + ",")) if ((not e1)) else None)
                _e1 = tink_json__Parser_JsonString_Impl_.toString(self.parseString())
                _hx___ret.h[_e0] = _e1
                while True:
                    tmp3 = None
                    if (self.pos < self.max):
                        this7 = self.source
                        i6 = self.pos
                        tmp3 = (((-1 if ((i6 >= len(this7))) else ord(this7[i6]))) < 33)
                    else:
                        tmp3 = False
                    if (not tmp3):
                        break
                    _hx_local_24 = self
                    _hx_local_25 = _hx_local_24.pos
                    _hx_local_24.pos = (_hx_local_25 + 1)
                    _hx_local_25
                tmp4 = None
                this8 = self.source
                i7 = self.pos
                if (((-1 if ((i7 >= len(this8))) else ord(this8[i7]))) == 93):
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.pos
                    _hx_local_26.pos = (_hx_local_27 + 1)
                    _hx_local_26.pos
                    while True:
                        tmp5 = None
                        if (self.pos < self.max):
                            this9 = self.source
                            i8 = self.pos
                            tmp5 = (((-1 if ((i8 >= len(this9))) else ord(this9[i8]))) < 33)
                        else:
                            tmp5 = False
                        if (not tmp5):
                            break
                        _hx_local_28 = self
                        _hx_local_29 = _hx_local_28.pos
                        _hx_local_28.pos = (_hx_local_29 + 1)
                        _hx_local_29
                    tmp4 = True
                else:
                    tmp4 = False
                if (not tmp4):
                    self.die(("Expected " + "]"))
                while True:
                    tmp6 = None
                    if (self.pos < self.max):
                        this10 = self.source
                        i9 = self.pos
                        tmp6 = (((-1 if ((i9 >= len(this10))) else ord(this10[i9]))) < 33)
                    else:
                        tmp6 = False
                    if (not tmp6):
                        break
                    _hx_local_30 = self
                    _hx_local_31 = _hx_local_30.pos
                    _hx_local_30.pos = (_hx_local_31 + 1)
                    _hx_local_31
                tmp7 = None
                this11 = self.source
                i10 = self.pos
                if (((-1 if ((i10 >= len(this11))) else ord(this11[i10]))) == 44):
                    _hx_local_32 = self
                    _hx_local_33 = _hx_local_32.pos
                    _hx_local_32.pos = (_hx_local_33 + 1)
                    _hx_local_32.pos
                    while True:
                        tmp8 = None
                        if (self.pos < self.max):
                            this12 = self.source
                            i11 = self.pos
                            tmp8 = (((-1 if ((i11 >= len(this12))) else ord(this12[i11]))) < 33)
                        else:
                            tmp8 = False
                        if (not tmp8):
                            break
                        _hx_local_34 = self
                        _hx_local_35 = _hx_local_34.pos
                        _hx_local_34.pos = (_hx_local_35 + 1)
                        _hx_local_35
                    tmp7 = True
                else:
                    tmp7 = False
                if (not tmp7):
                    break
            while True:
                tmp = None
                if (self.pos < self.max):
                    this1 = self.source
                    i = self.pos
                    tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                else:
                    tmp = False
                if (not tmp):
                    break
                _hx_local_36 = self
                _hx_local_37 = _hx_local_36.pos
                _hx_local_36.pos = (_hx_local_37 + 1)
                _hx_local_37
            tmp = None
            this1 = self.source
            i = self.pos
            if (((-1 if ((i >= len(this1))) else ord(this1[i]))) == 93):
                _hx_local_38 = self
                _hx_local_39 = _hx_local_38.pos
                _hx_local_38.pos = (_hx_local_39 + 1)
                _hx_local_38.pos
                while True:
                    tmp1 = None
                    if (self.pos < self.max):
                        this1 = self.source
                        i = self.pos
                        tmp1 = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp1 = False
                    if (not tmp1):
                        break
                    _hx_local_40 = self
                    _hx_local_41 = _hx_local_40.pos
                    _hx_local_40.pos = (_hx_local_41 + 1)
                    _hx_local_41
                tmp = True
            else:
                tmp = False
            if (not tmp):
                self.die(("Expected " + "]"))
        ret = _hx___ret
        _g = 0
        _g1 = self.afterParsing
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f()
        if (len(_gthis.afterParsing) > 0):
            _gthis.afterParsing = []
        return ret

    def tryParse(self,source):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                ret = _gthis.parse(source)
                while True:
                    tmp = None
                    if (_gthis.pos < _gthis.max):
                        this1 = _gthis.source
                        i = _gthis.pos
                        tmp = (((-1 if ((i >= len(this1))) else ord(this1[i]))) < 33)
                    else:
                        tmp = False
                    if (not tmp):
                        break
                    _gthis.pos = (_gthis.pos + 1)
                if (_gthis.pos < _gthis.max):
                    _gthis.die("Invalid data after JSON document")
                return ret
            return tink_core_TypedError.catchExceptions(_hx_local_1,None,_hx_AnonObject({'fileName': "tink/json/macros/Macro.hx", 'lineNumber': 107, 'className': "tink.json.Parser2", 'methodName': "tryParse"}))
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_json_Parser2._hx_class = tink_json_Parser2


class tink_json__Representation_Representation_Impl_:
    _hx_class_name = "tink.json._Representation.Representation_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get", "_new", "of"]

    @staticmethod
    def get(this1):
        return this1

    @staticmethod
    def _new(v):
        return v

    @staticmethod
    def of(v):
        return v
tink_json__Representation_Representation_Impl_._hx_class = tink_json__Representation_Representation_Impl_

class tink_json_Value(Enum):
    __slots__ = ()
    _hx_class_name = "tink.json.Value"
    _hx_constructs = ["VNumber", "VString", "VNull", "VBool", "VArray", "VObject"]

    @staticmethod
    def VNumber(f):
        return tink_json_Value("VNumber", 0, (f,))

    @staticmethod
    def VString(s):
        return tink_json_Value("VString", 1, (s,))

    @staticmethod
    def VBool(b):
        return tink_json_Value("VBool", 3, (b,))

    @staticmethod
    def VArray(a):
        return tink_json_Value("VArray", 4, (a,))

    @staticmethod
    def VObject(a):
        return tink_json_Value("VObject", 5, (a,))
tink_json_Value.VNull = tink_json_Value("VNull", 2, ())
tink_json_Value._hx_class = tink_json_Value


class tink_json_Writer:
    _hx_class_name = "tink.json.Writer"
    _hx_is_interface = "False"
    __slots__ = ()
tink_json_Writer._hx_class = tink_json_Writer


class tink_json_BasicWriter:
    _hx_class_name = "tink.json.BasicWriter"
    _hx_is_interface = "False"
    __slots__ = ("plugins", "buf")
    _hx_fields = ["plugins", "buf"]
    _hx_methods = ["init", "output", "char", "writeInt", "writeFloat", "writeBool", "writeString", "writeDynamic", "writeValue", "expandScientificNotation"]

    def __init__(self):
        self.buf = None
        self.plugins = None
        self.plugins = tink_core_Annex(self)

    def init(self):
        self.buf = StringBuf()

    def output(self,s):
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def char(self,c):
        _this = self.buf
        s = "".join(map(chr,[c]))
        _this.b.write(s)

    def writeInt(self,v):
        s = Std.string(v)
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def writeFloat(self,v):
        s = Std.string(v)
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def writeBool(self,b):
        self.buf.b.write(("true" if b else "false"))

    def writeString(self,s):
        s1 = tink_json__Writer_StringWriter.encoder.encode(s)
        _this = self.buf
        s = Std.string(s1)
        _this.b.write(s)

    def writeDynamic(self,value):
        s = haxe_format_JsonPrinter.print(value)
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)

    def writeValue(self,value):
        _gthis = self
        tmp = value.index
        if (tmp == 0):
            f = value.params[0]
            s = Std.string(f)
            _this = self.buf
            s1 = Std.string(s)
            _this.b.write(s1)
        elif (tmp == 1):
            s = value.params[0]
            s1 = tink_json__Writer_StringWriter.encoder.encode(s)
            _this = self.buf
            s = Std.string(s1)
            _this.b.write(s)
        elif (tmp == 2):
            self.buf.b.write("null")
        elif (tmp == 3):
            b = value.params[0]
            self.buf.b.write(("true" if b else "false"))
        elif (tmp == 4):
            _g = value.params[0]
            if (len(_g) == 0):
                self.buf.b.write("[]")
            else:
                a = _g
                _this = self.buf
                s = "".join(map(chr,[91]))
                _this.b.write(s)
                self.writeValue((a[0] if 0 < len(a) else None))
                _g = 1
                _g1 = len(a)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = self.buf
                    s = "".join(map(chr,[44]))
                    _this.b.write(s)
                    self.writeValue((a[i] if i >= 0 and i < len(a) else None))
                _this = self.buf
                s = "".join(map(chr,[93]))
                _this.b.write(s)
        elif (tmp == 5):
            _g = value.params[0]
            if (len(_g) == 0):
                self.buf.b.write("{}")
            else:
                a = _g
                _this = self.buf
                s = "".join(map(chr,[123]))
                _this.b.write(s)
                p = (a[0] if 0 < len(a) else None)
                s = tink_json__Writer_StringWriter.encoder.encode(p.name)
                _this = _gthis.buf
                s1 = Std.string(s)
                _this.b.write(s1)
                _this = _gthis.buf
                s = "".join(map(chr,[58]))
                _this.b.write(s)
                _gthis.writeValue(p.value)
                _g = 1
                _g1 = len(a)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    _this = self.buf
                    s = "".join(map(chr,[44]))
                    _this.b.write(s)
                    p = (a[i] if i >= 0 and i < len(a) else None)
                    s1 = tink_json__Writer_StringWriter.encoder.encode(p.name)
                    _this1 = _gthis.buf
                    s2 = Std.string(s1)
                    _this1.b.write(s2)
                    _this2 = _gthis.buf
                    s3 = "".join(map(chr,[58]))
                    _this2.b.write(s3)
                    _gthis.writeValue(p.value)
                _this = self.buf
                s = "".join(map(chr,[125]))
                _this.b.write(s)
        else:
            pass

    def expandScientificNotation(self,v):
        _this = v.lower()
        _g = _this.split("e")
        _g1 = len(_g)
        if (_g1 == 1):
            d = (_g[0] if 0 < len(_g) else None)
            return d
        elif (_g1 == 2):
            d = (_g[0] if 0 < len(_g) else None)
            e = (_g[1] if 1 < len(_g) else None)
            _g = d.split(".")
            _g1 = len(_g)
            if (_g1 == 1):
                v = (_g[0] if 0 < len(_g) else None)
                return (("null" if v is None else v) + HxOverrides.stringOrNull(StringTools.rpad("","0",Std.parseInt(e))))
            elif (_g1 == 2):
                d = (_g[0] if 0 < len(_g) else None)
                f = (_g[1] if 1 < len(_g) else None)
                return (("null" if d is None else d) + HxOverrides.stringOrNull(StringTools.rpad(f,"0",Std.parseInt(e))))
            else:
                raise haxe_Exception.thrown("Invalid value")
        else:
            raise haxe_Exception.thrown("Invalid value")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.plugins = None
        _hx_o.buf = None
tink_json_BasicWriter._hx_class = tink_json_BasicWriter


class tink_json__Writer_StringWriter:
    _hx_class_name = "tink.json._Writer.StringWriter"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["encoder", "stringify"]

    @staticmethod
    def stringify(v):
        return tink_json__Writer_StringWriter.encoder.encode(v)
tink_json__Writer_StringWriter._hx_class = tink_json__Writer_StringWriter


class tink_json__Writer_StdWriter:
    _hx_class_name = "tink.json._Writer.StdWriter"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["stringify"]

    @staticmethod
    def stringify(v):
        return haxe_format_JsonPrinter.print(v)
tink_json__Writer_StdWriter._hx_class = tink_json__Writer_StdWriter


class tink_json_Writer0(tink_json_BasicWriter):
    _hx_class_name = "tink.json.Writer0"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_json_BasicWriter


    def __init__(self):
        super().__init__()

    def write(self,value):
        self.init()
        s = tink_json__Writer_StringWriter.encoder.encode(value)
        _this = self.buf
        s1 = Std.string(s)
        _this.b.write(s1)
        return self.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_json_Writer0._hx_class = tink_json_Writer0


class uuid_Uuid:
    _hx_class_name = "uuid.Uuid"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["DNS", "URL", "ISO_OID", "X500_DN", "NIL", "LOWERCASE_BASE26", "UPPERCASE_BASE26", "NO_LOOK_ALIKES_BASE51", "FLICKR_BASE58", "BASE_70", "BASE_85", "COOKIE_BASE90", "NANO_ID_ALPHABET", "NUMBERS_BIN", "NUMBERS_OCT", "NUMBERS_DEC", "NUMBERS_HEX", "lastMSecs", "lastNSecs", "clockSequenceBuffer", "regexp", "rndSeed", "state0", "state1", "DVS", "splitmix64_seed", "randomFromRange", "randomByte", "fromShort", "toShort", "fromNano", "toNano", "v1", "v3", "v4", "v5", "stringify", "parse", "validate", "version", "hexToUuid", "convert", "nanoId", "short"]

    @staticmethod
    def splitmix64_seed(index):
        b_high = -1640531527
        b_low = 2135587861
        high = (((index.high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((index.low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,index.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        result = haxe__Int64____Int64(high,low)
        b = 30
        b = (b & 63)
        b1 = (haxe__Int64____Int64(result.high,result.low) if ((b == 0)) else (haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))))
        a_high = ((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b_high = -1084733587
        b_low = 484763065
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        result = haxe__Int64____Int64(high,low)
        b = 27
        b = (b & 63)
        b1 = (haxe__Int64____Int64(result.high,result.low) if ((b == 0)) else (haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))))
        a_high = ((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b_high = -1798288965
        b_low = 321982955
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        result = haxe__Int64____Int64(high,low)
        b = 31
        b = (b & 63)
        b1 = (haxe__Int64____Int64(result.high,result.low) if ((b == 0)) else (haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))))
        return haxe__Int64____Int64(((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))

    @staticmethod
    def randomFromRange(_hx_min,_hx_max):
        s1 = uuid_Uuid.state0
        s0 = uuid_Uuid.state1
        uuid_Uuid.state0 = s0
        b = 23
        b = (b & 63)
        b1 = (haxe__Int64____Int64(s1.high,s1.low) if ((b == 0)) else (haxe__Int64____Int64(((((((((s1.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s1.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((s1.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(((((s1.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)))
        s1 = haxe__Int64____Int64(((((s1.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((s1.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        a_high = ((((s1.high ^ s0.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((s1.low ^ s0.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b = 18
        b = (b & 63)
        b1 = (haxe__Int64____Int64(s1.high,s1.low) if ((b == 0)) else (haxe__Int64____Int64(HxOverrides.rshift(s1.high, b),((((((((s1.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s1.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(0,HxOverrides.rshift(s1.high, ((b - 32))))))
        a_high1 = ((((a_high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low1 = ((((a_low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b = 5
        b = (b & 63)
        b1 = (haxe__Int64____Int64(s0.high,s0.low) if ((b == 0)) else (haxe__Int64____Int64(HxOverrides.rshift(s0.high, b),((((((((s0.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s0.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b < 32)) else haxe__Int64____Int64(0,HxOverrides.rshift(s0.high, ((b - 32))))))
        uuid_Uuid.state1 = haxe__Int64____Int64(((((a_high1 ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a_low1 ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        a = uuid_Uuid.state1
        high = (((a.high + s0.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low + s0.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        x = ((_hx_max - _hx_min) + 1)
        result = haxe__Int64_Int64_Impl_.divMod(haxe__Int64____Int64(high,low),haxe__Int64____Int64((x >> 31),x)).modulus.low
        if (result < 0):
            result = -result
        return (result + _hx_min)

    @staticmethod
    def randomByte():
        return uuid_Uuid.randomFromRange(0,255)

    @staticmethod
    def fromShort(shortUuid,separator = None,fromAlphabet = None):
        if (separator is None):
            separator = "-"
        if (fromAlphabet is None):
            fromAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        uuid = uuid_Uuid.convert(shortUuid,fromAlphabet,"0123456789abcdef")
        return uuid_Uuid.hexToUuid(uuid,separator)

    @staticmethod
    def toShort(uuid,separator = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        uuid = StringTools.replace(uuid,separator,"").lower()
        return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet)

    @staticmethod
    def fromNano(nanoUuid,separator = None,fromAlphabet = None):
        if (separator is None):
            separator = "-"
        if (fromAlphabet is None):
            fromAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        uuid = uuid_Uuid.convert(nanoUuid,fromAlphabet,"0123456789abcdef")
        return uuid_Uuid.hexToUuid(uuid,separator)

    @staticmethod
    def toNano(uuid,separator = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (toAlphabet is None):
            toAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        uuid = StringTools.replace(uuid,separator,"").lower()
        return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet)

    @staticmethod
    def v1(node = None,optClockSequence = None,msecs = None,optNsecs = None,randomFunc = None,separator = None,shortUuid = None,toAlphabet = None):
        if (optClockSequence is None):
            optClockSequence = -1
        if (msecs is None):
            msecs = -1
        if (optNsecs is None):
            optNsecs = -1
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        buffer = haxe_io_Bytes.alloc(16)
        if (node is None):
            node = haxe_io_Bytes.alloc(6)
            v = randomFunc()
            node.b[0] = (v & 255)
            v = randomFunc()
            node.b[1] = (v & 255)
            v = randomFunc()
            node.b[2] = (v & 255)
            v = randomFunc()
            node.b[3] = (v & 255)
            v = randomFunc()
            node.b[4] = (v & 255)
            v = randomFunc()
            node.b[5] = (v & 255)
            v = (node.b[0] | 1)
            node.b[0] = (v & 255)
        if (uuid_Uuid.clockSequenceBuffer == -1):
            uuid_Uuid.clockSequenceBuffer = ((((randomFunc() << 8) | randomFunc())) & 16383)
        clockSeq = optClockSequence
        if (optClockSequence == -1):
            clockSeq = uuid_Uuid.clockSequenceBuffer
        if (msecs == -1):
            v = (python_lib_Time.time() * 1000)
            msecs = (v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.floor((v + 0.5))))
        nsecs = optNsecs
        if (optNsecs == -1):
            nsecs = (uuid_Uuid.lastNSecs + 1)
        dt = ((msecs - uuid_Uuid.lastMSecs) + ((((nsecs - uuid_Uuid.lastNSecs)) / 10000)))
        if ((dt < 0) and ((optClockSequence == -1))):
            clockSeq = ((clockSeq + 1) & 16383)
        if ((((dt < 0) or ((msecs > uuid_Uuid.lastMSecs)))) and ((optNsecs == -1))):
            nsecs = 0
        if (nsecs >= 10000):
            raise haxe_Exception.thrown("Can't create more than 10M uuids/sec")
        uuid_Uuid.lastMSecs = msecs
        uuid_Uuid.lastNSecs = nsecs
        uuid_Uuid.clockSequenceBuffer = clockSeq
        msecs = (msecs + 12219292800000)
        imsecs = haxe_Int64Helper.fromFloat(msecs)
        b_high = 0
        b_low = 268435455
        a_high = (imsecs.high & b_high)
        a_low = (imsecs.low & b_low)
        b_high = 0
        b_low = 10000
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_high = high
        a_low = low
        b_high = (nsecs >> 31)
        b_low = nsecs
        high = (((a_high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a_low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a_low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        tl = haxe__Int64_Int64_Impl_.divMod(haxe__Int64____Int64(high,low),uuid_Uuid.DVS).modulus.low
        buffer.b[0] = ((HxOverrides.rshift(tl, 24) & 255) & 255)
        buffer.b[1] = ((HxOverrides.rshift(tl, 16) & 255) & 255)
        buffer.b[2] = ((HxOverrides.rshift(tl, 8) & 255) & 255)
        buffer.b[3] = ((tl & 255) & 255)
        a = haxe__Int64_Int64_Impl_.divMod(imsecs,uuid_Uuid.DVS).quotient
        b_high = 0
        b_low = 10000
        mask = 65535
        al = (a.low & mask)
        ah = HxOverrides.rshift(a.low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a.low,b_high) + haxe__Int32_Int32_Impl_.mul(a.high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_high = high
        a_low = low
        b_high = 0
        b_low = 268435455
        this_high = (a_high & b_high)
        this_low = (a_low & b_low)
        tmh = this_low
        buffer.b[4] = ((HxOverrides.rshift(tmh, 8) & 255) & 255)
        buffer.b[5] = ((tmh & 255) & 255)
        buffer.b[6] = ((((HxOverrides.rshift(tmh, 24) & 15) | 16)) & 255)
        buffer.b[7] = ((HxOverrides.rshift(tmh, 16) & 255) & 255)
        buffer.b[8] = (((HxOverrides.rshift(clockSeq, 8) | 128)) & 255)
        buffer.b[9] = ((clockSeq & 255) & 255)
        v = node.b[0]
        buffer.b[10] = (v & 255)
        v = node.b[1]
        buffer.b[11] = (v & 255)
        v = node.b[2]
        buffer.b[12] = (v & 255)
        v = node.b[3]
        buffer.b[13] = (v & 255)
        v = node.b[4]
        buffer.b[14] = (v & 255)
        v = node.b[5]
        buffer.b[15] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v3(name,namespace = None,separator = None,shortUuid = None,toAlphabet = None):
        if (namespace is None):
            namespace = ""
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        namespace = StringTools.replace(namespace,"-","")
        buffer = haxe_crypto_Md5.make(haxe_io_Bytes.ofHex((("null" if namespace is None else namespace) + HxOverrides.stringOrNull(haxe_io_Bytes.ofString(name).toHex()))))
        v = ((buffer.b[6] & 15) | 48)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v4(randBytes = None,randomFunc = None,separator = None,shortUuid = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        buffer = randBytes
        if (buffer is None):
            buffer = haxe_io_Bytes.alloc(16)
            v = randomFunc()
            buffer.b[0] = (v & 255)
            v = randomFunc()
            buffer.b[1] = (v & 255)
            v = randomFunc()
            buffer.b[2] = (v & 255)
            v = randomFunc()
            buffer.b[3] = (v & 255)
            v = randomFunc()
            buffer.b[4] = (v & 255)
            v = randomFunc()
            buffer.b[5] = (v & 255)
            v = randomFunc()
            buffer.b[6] = (v & 255)
            v = randomFunc()
            buffer.b[7] = (v & 255)
            v = randomFunc()
            buffer.b[8] = (v & 255)
            v = randomFunc()
            buffer.b[9] = (v & 255)
            v = randomFunc()
            buffer.b[10] = (v & 255)
            v = randomFunc()
            buffer.b[11] = (v & 255)
            v = randomFunc()
            buffer.b[12] = (v & 255)
            v = randomFunc()
            buffer.b[13] = (v & 255)
            v = randomFunc()
            buffer.b[14] = (v & 255)
            v = randomFunc()
            buffer.b[15] = (v & 255)
        elif (buffer.length < 16):
            raise haxe_Exception.thrown("Random bytes should be at least 16 bytes")
        v = ((buffer.b[6] & 15) | 64)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v5(name,namespace = None,separator = None,shortUuid = None,toAlphabet = None):
        if (namespace is None):
            namespace = ""
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        namespace = StringTools.replace(namespace,"-","")
        buffer = haxe_crypto_Sha1.make(haxe_io_Bytes.ofHex((("null" if namespace is None else namespace) + HxOverrides.stringOrNull(haxe_io_Bytes.ofString(name).toHex()))))
        v = ((buffer.b[6] & 15) | 80)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def stringify(data,separator = None):
        if (separator is None):
            separator = "-"
        return uuid_Uuid.hexToUuid(data.toHex(),separator)

    @staticmethod
    def parse(uuid,separator = None):
        if (separator is None):
            separator = "-"
        return haxe_io_Bytes.ofHex(StringTools.replace(uuid,separator,""))

    @staticmethod
    def validate(uuid,separator = None):
        if (separator is None):
            separator = "-"
        if (separator == ""):
            uuid = ((((((((HxOverrides.stringOrNull(HxString.substr(uuid,0,8)) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,8,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,12,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,16,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,20,12)))
        elif (separator != "-"):
            uuid = StringTools.replace(uuid,separator,"-")
        _this = uuid_Uuid.regexp
        _this.matchObj = python_lib_Re.search(_this.pattern,uuid)
        return (_this.matchObj is not None)

    @staticmethod
    def version(uuid,separator = None):
        if (separator is None):
            separator = "-"
        uuid = StringTools.replace(uuid,separator,"")
        return Std.parseInt(("0x" + HxOverrides.stringOrNull(HxString.substr(uuid,12,1))))

    @staticmethod
    def hexToUuid(hex,separator):
        return ((((((((HxOverrides.stringOrNull(HxString.substr(hex,0,8)) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,8,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,12,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,16,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,20,12)))

    @staticmethod
    def convert(number,fromAlphabet,toAlphabet):
        fromBase = len(fromAlphabet)
        toBase = len(toAlphabet)
        _hx_len = len(number)
        buf = ""
        numberMap = ([None]*_hx_len)
        divide = 0
        newlen = 0
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_str = ("" if (((i < 0) or ((i >= len(number))))) else number[i])
            startIndex = None
            val = (fromAlphabet.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(fromAlphabet,_hx_str,startIndex))
            numberMap[i] = val
        while True:
            divide = 0
            newlen = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                divide = ((divide * fromBase) + numberMap[i])
                if (divide >= toBase):
                    index = newlen
                    newlen = (newlen + 1)
                    val = Math.floor((divide / toBase))
                    numberMap[index] = val
                    divide = HxOverrides.mod(divide, toBase)
                elif (newlen > 0):
                    index1 = newlen
                    newlen = (newlen + 1)
                    numberMap[index1] = 0
            _hx_len = newlen
            buf = (HxOverrides.stringOrNull((("" if (((divide < 0) or ((divide >= len(toAlphabet))))) else toAlphabet[divide]))) + ("null" if buf is None else buf))
            if (not ((newlen != 0))):
                break
        return buf

    @staticmethod
    def nanoId(_hx_len = None,alphabet = None,randomFunc = None):
        if (_hx_len is None):
            _hx_len = 21
        if (alphabet is None):
            alphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        if (alphabet is None):
            raise haxe_Exception.thrown("Alphabet cannot be null")
        if ((len(alphabet) == 0) or ((len(alphabet) >= 256))):
            raise haxe_Exception.thrown("Alphabet must contain between 1 and 255 symbols")
        if (_hx_len <= 0):
            raise haxe_Exception.thrown("Length must be greater than zero")
        v = (len(alphabet) - 1)
        mask = (((2 << Math.floor((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(2))))) - 1)
        step = Math.ceil((((1.6 * mask) * _hx_len) / len(alphabet)))
        sb = StringBuf()
        while (sb.get_length() != _hx_len):
            _g = 0
            _g1 = step
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                rnd = randomFunc()
                aIndex = (rnd & mask)
                if (aIndex < len(alphabet)):
                    s = Std.string(("" if (((aIndex < 0) or ((aIndex >= len(alphabet))))) else alphabet[aIndex]))
                    sb.b.write(s)
                    if (sb.get_length() == _hx_len):
                        break
        return sb.b.getvalue()

    @staticmethod
    def short(toAlphabet = None,randomFunc = None):
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        return uuid_Uuid.v4(None,randomFunc,None,True,toAlphabet)
uuid_Uuid._hx_class = uuid_Uuid

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi
sys_thread__Thread_HxThread.threads = haxe_ds_ObjectMap()
sys_thread__Thread_HxThread.threadsMutex = sys_thread_Mutex()
sys_thread__Thread_HxThread.mainThread = sys_thread__Thread_HxThread(python_lib_Threading.current_thread())
sys_thread__Thread_HxThread.mainThread.events = sys_thread_EventLoop()

python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
kiss_Prelude._hx_and = Reflect.makeVarArgs(kiss_Prelude._and)
kiss_Prelude._hx_or = Reflect.makeVarArgs(kiss_Prelude._or)
kiss_Prelude.add = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._add,"+")
kiss_Prelude.subtract = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._subtract,"-")
kiss_Prelude.multiply = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._multiply,"*")
kiss_Prelude.divide = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._divide,"/")
kiss_Prelude.min = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._min,"min")
kiss_Prelude.max = kiss_Prelude.makeVarArgsWithArrayCheck(kiss_Prelude._max,"max")
def _hx_init_kiss_Prelude_greaterThan():
    def _hx_local_0():
        op = ">"
        def _hx_local_2():
            def _hx_local_1(values):
                return kiss_Prelude._comparison(op,values)
            return kiss_Prelude.makeVarArgsWithArrayCheck(_hx_local_1,">")
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.greaterThan = _hx_init_kiss_Prelude_greaterThan()
def _hx_init_kiss_Prelude_greaterEqual():
    def _hx_local_0():
        op = ">="
        def _hx_local_2():
            def _hx_local_1(values):
                return kiss_Prelude._comparison(op,values)
            return kiss_Prelude.makeVarArgsWithArrayCheck(_hx_local_1,">=")
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.greaterEqual = _hx_init_kiss_Prelude_greaterEqual()
def _hx_init_kiss_Prelude_lessThan():
    def _hx_local_0():
        op = "<"
        def _hx_local_2():
            def _hx_local_1(values):
                return kiss_Prelude._comparison(op,values)
            return kiss_Prelude.makeVarArgsWithArrayCheck(_hx_local_1,"<")
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.lessThan = _hx_init_kiss_Prelude_lessThan()
def _hx_init_kiss_Prelude_lesserEqual():
    def _hx_local_0():
        op = "<="
        def _hx_local_2():
            def _hx_local_1(values):
                return kiss_Prelude._comparison(op,values)
            return kiss_Prelude.makeVarArgsWithArrayCheck(_hx_local_1,"<=")
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.lesserEqual = _hx_init_kiss_Prelude_lesserEqual()
def _hx_init_kiss_Prelude_areEqual():
    def _hx_local_0():
        op = "=="
        def _hx_local_2():
            def _hx_local_1(values):
                return kiss_Prelude._comparison(op,values)
            return kiss_Prelude.makeVarArgsWithArrayCheck(_hx_local_1,"=")
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.areEqual = _hx_init_kiss_Prelude_areEqual()
def _hx_init_kiss_Prelude_iHalf():
    def _hx_local_0():
        denom = 2
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iHalf = _hx_init_kiss_Prelude_iHalf()
def _hx_init_kiss_Prelude_iThird():
    def _hx_local_0():
        denom = 3
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iThird = _hx_init_kiss_Prelude_iThird()
def _hx_init_kiss_Prelude_iFourth():
    def _hx_local_0():
        denom = 4
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iFourth = _hx_init_kiss_Prelude_iFourth()
def _hx_init_kiss_Prelude_iFifth():
    def _hx_local_0():
        denom = 5
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iFifth = _hx_init_kiss_Prelude_iFifth()
def _hx_init_kiss_Prelude_iSixth():
    def _hx_local_0():
        denom = 6
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iSixth = _hx_init_kiss_Prelude_iSixth()
def _hx_init_kiss_Prelude_iSeventh():
    def _hx_local_0():
        denom = 7
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iSeventh = _hx_init_kiss_Prelude_iSeventh()
def _hx_init_kiss_Prelude_iEighth():
    def _hx_local_0():
        denom = 8
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iEighth = _hx_init_kiss_Prelude_iEighth()
def _hx_init_kiss_Prelude_iNinth():
    def _hx_local_0():
        denom = 9
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iNinth = _hx_init_kiss_Prelude_iNinth()
def _hx_init_kiss_Prelude_iTenth():
    def _hx_local_0():
        denom = 10
        def _hx_local_1(num):
            return kiss_Prelude.iFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.iTenth = _hx_init_kiss_Prelude_iTenth()
def _hx_init_kiss_Prelude_fHalf():
    def _hx_local_0():
        denom = 2
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fHalf = _hx_init_kiss_Prelude_fHalf()
def _hx_init_kiss_Prelude_fThird():
    def _hx_local_0():
        denom = 3
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fThird = _hx_init_kiss_Prelude_fThird()
def _hx_init_kiss_Prelude_fFourth():
    def _hx_local_0():
        denom = 4
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fFourth = _hx_init_kiss_Prelude_fFourth()
def _hx_init_kiss_Prelude_fFifth():
    def _hx_local_0():
        denom = 5
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fFifth = _hx_init_kiss_Prelude_fFifth()
def _hx_init_kiss_Prelude_fSixth():
    def _hx_local_0():
        denom = 6
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fSixth = _hx_init_kiss_Prelude_fSixth()
def _hx_init_kiss_Prelude_fSeventh():
    def _hx_local_0():
        denom = 7
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fSeventh = _hx_init_kiss_Prelude_fSeventh()
def _hx_init_kiss_Prelude_fEighth():
    def _hx_local_0():
        denom = 8
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fEighth = _hx_init_kiss_Prelude_fEighth()
def _hx_init_kiss_Prelude_fNinth():
    def _hx_local_0():
        denom = 9
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fNinth = _hx_init_kiss_Prelude_fNinth()
def _hx_init_kiss_Prelude_fTenth():
    def _hx_local_0():
        denom = 10
        def _hx_local_1(num):
            return kiss_Prelude.fFraction(num,denom)
        return _hx_local_1
    return _hx_local_0()
kiss_Prelude.fTenth = _hx_init_kiss_Prelude_fTenth()
kiss_Prelude.concat = Reflect.makeVarArgs(kiss_Prelude._concat)
def _hx_init_kiss_Prelude_zipKeep():
    def _hx_local_0():
        extraHandling = kiss_ExtraElementHandling.Keep
        def _hx_local_2():
            def _hx_local_1(iterables):
                return kiss_Prelude._zip(iterables,extraHandling)
            return Reflect.makeVarArgs(_hx_local_1)
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.zipKeep = _hx_init_kiss_Prelude_zipKeep()
def _hx_init_kiss_Prelude_zipDrop():
    def _hx_local_0():
        extraHandling = kiss_ExtraElementHandling.Drop
        def _hx_local_2():
            def _hx_local_1(iterables):
                return kiss_Prelude._zip(iterables,extraHandling)
            return Reflect.makeVarArgs(_hx_local_1)
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.zipDrop = _hx_init_kiss_Prelude_zipDrop()
def _hx_init_kiss_Prelude_zipThrow():
    def _hx_local_0():
        extraHandling = kiss_ExtraElementHandling.Throw
        def _hx_local_2():
            def _hx_local_1(iterables):
                return kiss_Prelude._zip(iterables,extraHandling)
            return Reflect.makeVarArgs(_hx_local_1)
        return _hx_local_2()
    return _hx_local_0()
kiss_Prelude.zipThrow = _hx_init_kiss_Prelude_zipThrow()
kiss_Prelude.intersect = Reflect.makeVarArgs(kiss_Prelude._intersect)
kiss_Prelude.joinPath = Reflect.makeVarArgs(kiss_Prelude._joinPath)
kiss_Prelude.externLogFile = "externLog.txt"
kiss_Prelude.printStr = kiss_Prelude._printStr
kiss_Prelude.kissProcess = None
kiss_Prelude.cachedConvertToHScript = kiss_Prelude.fsMemoize(kiss_Prelude.convertToHScript,"convertToHScript",(("" + HxOverrides.stringOrNull(kiss_Prelude.userHome())) + "/.kiss-cache"))
kiss_Prelude.shellCountMutex = sys_thread_Mutex()
kiss_Prelude.shellCount = 0
kiss_Prelude.newLine = "\n"
kiss_Prelude.backSlash = "\\"
kiss_Prelude.doubleQuote = "\""
kiss_Prelude.dollar = "$"
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 100
tink_core_AlreadyDisposed.INST = tink_core_AlreadyDisposed()
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NEVER_INST = tink_core__Future_FutureObject()
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_Future_Impl_.NEVER_INST
tink_core__Lazy_Lazy_Impl_.NOISE = tink_core__Lazy_LazyConst(None)
tink_core__Lazy_Lazy_Impl_.NULL = tink_core__Lazy_Lazy_Impl_.NOISE
tink_core__Noise_Noise_Impl_.Noise = None
tink_core__Progress_ProgressValue_Impl_.ZERO = tink_core_MPair(0,haxe_ds_Option._hx_None)
tink_core__Progress_Progress_Impl_.INIT = tink_core__Progress_ProgressValue_Impl_.ZERO
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NEVER = tink_core__Promise_Promise_Impl_.never()
tink_core__Signal_Disposed.INST = tink_core__Signal_Disposed()
tink_json_BasicParser.DBQT = "".join(map(chr,[34]))
tink_json__Writer_StringWriter.encoder = python_lib_json_JSONEncoder()
uuid_Uuid.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.ISO_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.X500_DN = "6ba7b814-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.NIL = "00000000-0000-0000-0000-000000000000"
uuid_Uuid.LOWERCASE_BASE26 = "abcdefghijklmnopqrstuvwxyz"
uuid_Uuid.UPPERCASE_BASE26 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
uuid_Uuid.NO_LOOK_ALIKES_BASE51 = "2346789ABCDEFGHJKLMNPQRTUVWXYZabcdefghijkmnpqrtwxyz"
uuid_Uuid.FLICKR_BASE58 = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
uuid_Uuid.BASE_70 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+!@#$^"
uuid_Uuid.BASE_85 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"
uuid_Uuid.COOKIE_BASE90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~"
uuid_Uuid.NANO_ID_ALPHABET = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
uuid_Uuid.NUMBERS_BIN = "01"
uuid_Uuid.NUMBERS_OCT = "01234567"
uuid_Uuid.NUMBERS_DEC = "0123456789"
uuid_Uuid.NUMBERS_HEX = "0123456789abcdef"
uuid_Uuid.lastMSecs = 0
uuid_Uuid.lastNSecs = 0
uuid_Uuid.clockSequenceBuffer = -1
uuid_Uuid.regexp = EReg("^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$","i")
uuid_Uuid.rndSeed = haxe_Int64Helper.fromFloat((python_lib_Time.time() * 1000))
uuid_Uuid.state0 = uuid_Uuid.splitmix64_seed(uuid_Uuid.rndSeed)
def _hx_init_uuid_Uuid_state1():
    def _hx_local_0():
        a = uuid_Uuid.rndSeed
        x = int((python_lib_Random.random() * 10000))
        b_high = (x >> 31)
        b_low = x
        high = (((a.high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_high = high
        a_low = low
        b_high = 0
        b_low = 1
        high = (((a_high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a_low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a_low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        return uuid_Uuid.splitmix64_seed(haxe__Int64____Int64(high,low))
    return _hx_local_0()
uuid_Uuid.state1 = _hx_init_uuid_Uuid_state1()
uuid_Uuid.DVS = haxe__Int64____Int64(1,0)

ExternMain.main()
sys_thread__Thread_Thread_Impl_.processEvents()
